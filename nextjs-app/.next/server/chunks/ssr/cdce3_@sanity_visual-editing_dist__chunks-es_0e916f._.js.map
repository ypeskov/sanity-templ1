{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"transformSanityNodeData.js","sources":["file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing-helpers/dist/_chunks-es/transformSanityNodeData.js"],"sourcesContent":["import { getPublishedId, studioPath } from \"@sanity/client/csm\";\nimport { pipe, string, minLength, optional, object, record, unknown, is, safeParse, parse } from \"valibot\";\nfunction isRecord(value) {\n  return typeof value == \"object\" && value !== null && !Array.isArray(value);\n}\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\nfunction pathToUrlString(path) {\n  let str = \"\";\n  for (const segment of path) {\n    if (typeof segment == \"string\") {\n      str && (str += \".\"), str += segment;\n      continue;\n    }\n    if (typeof segment == \"number\") {\n      str && (str += \":\"), str += `${segment}`;\n      continue;\n    }\n    if (isArray(segment)) {\n      str && (str += \":\"), str += `${segment.join(\",\")}}`;\n      continue;\n    }\n    if (segment._key) {\n      str && (str += \":\"), str += `${segment._key}`;\n      continue;\n    }\n  }\n  return str;\n}\nconst RE_SEGMENT_WITH_INDEX = /^([\\w-]+):(0|[1-9][0-9]*)$/, RE_SEGMENT_WITH_TUPLE = /^([\\w-]+):([0-9]+),([0-9]+)$/, RE_SEGMENT_WITH_KEY = /^([\\w-]+):([\\w-]+)$/;\nfunction urlStringToPath(str) {\n  const path = [];\n  for (const segment of str.split(\".\")) {\n    const withIndex = RE_SEGMENT_WITH_INDEX.exec(segment);\n    if (withIndex) {\n      path.push(withIndex[1], Number(withIndex[2]));\n      continue;\n    }\n    const withTuple = RE_SEGMENT_WITH_TUPLE.exec(segment);\n    if (withTuple) {\n      path.push(withTuple[1], [Number(withTuple[2]), Number(withTuple[3])]);\n      continue;\n    }\n    const withKey = RE_SEGMENT_WITH_KEY.exec(segment);\n    if (withKey) {\n      path.push(withKey[1], { _key: withKey[2] });\n      continue;\n    }\n    path.push(segment);\n  }\n  return path;\n}\nconst DRAFTS_PREFIX = \"drafts.\", lengthyStr = pipe(string(), minLength(1)), optionalLengthyStr = optional(lengthyStr), sanityNodeSchema = object({\n  baseUrl: lengthyStr,\n  dataset: optionalLengthyStr,\n  id: lengthyStr,\n  path: lengthyStr,\n  projectId: optionalLengthyStr,\n  tool: optionalLengthyStr,\n  type: optionalLengthyStr,\n  workspace: optionalLengthyStr,\n  isDraft: optional(string())\n}), sanityLegacyNodeSchema = object({\n  origin: lengthyStr,\n  href: lengthyStr,\n  data: optional(record(string(), unknown()))\n});\nfunction isValidSanityNode(node) {\n  return is(sanityNodeSchema, node);\n}\nfunction isValidSanityLegacyNode(node) {\n  return is(sanityLegacyNodeSchema, node);\n}\nfunction encodeSanityNodeData(node) {\n  const { id: _id, path, baseUrl, tool, workspace, type } = node;\n  return isValidSanityNode(node) ? [\n    [\"id\", getPublishedId(_id)],\n    [\"type\", type],\n    [\"path\", pathToUrlString(studioPath.fromString(path))],\n    [\"base\", encodeURIComponent(baseUrl)],\n    [\"workspace\", workspace],\n    [\"tool\", tool],\n    [\"isDraft\", _id.startsWith(DRAFTS_PREFIX)]\n  ].filter(([, value]) => !!value).map((part) => {\n    const [key, value] = part;\n    return value === !0 ? key : part.join(\"=\");\n  }).join(\";\") : void 0;\n}\nfunction decodeSanityString(str) {\n  const data = str.split(\";\").reduce((acc, segment) => {\n    const [key, value] = segment.split(\"=\");\n    if (!key || segment.includes(\"=\") && !value) return acc;\n    switch (key) {\n      case \"id\":\n        acc.id = value;\n        break;\n      case \"type\":\n        acc.type = value;\n        break;\n      case \"path\":\n        acc.path = studioPath.toString(urlStringToPath(value));\n        break;\n      case \"base\":\n        acc.baseUrl = decodeURIComponent(value);\n        break;\n      case \"tool\":\n        acc.tool = value;\n        break;\n      case \"workspace\":\n        acc.workspace = value;\n        break;\n      case \"projectId\":\n        acc.projectId = value;\n        break;\n      case \"dataset\":\n        acc.dataset = value;\n        break;\n      case \"isDraft\":\n        acc.isDraft = \"\";\n        break;\n    }\n    return acc;\n  }, {});\n  if (isValidSanityNode(data))\n    return data;\n}\nfunction decodeSanityObject(data) {\n  const sanityNode = safeParse(sanityNodeSchema, data);\n  if (sanityNode.success)\n    return sanityNode.output;\n  const sanityLegacyNode = safeParse(sanityLegacyNodeSchema, data);\n  if (sanityLegacyNode.success)\n    try {\n      const url = new URL(\n        sanityLegacyNode.output.href,\n        typeof document > \"u\" ? \"https://example.com\" : location.origin\n      );\n      return url.searchParams.size > 0 ? parse(sanityNodeSchema, Object.fromEntries(url.searchParams.entries())) : sanityLegacyNode.output;\n    } catch (err) {\n      return console.error(\"Failed to parse sanity node\", err), sanityLegacyNode.output;\n    }\n}\nfunction decodeSanityNodeData(data) {\n  if (typeof data == \"object\" && data !== null)\n    return decodeSanityObject(data);\n  try {\n    const obj = JSON.parse(data);\n    return decodeSanityObject(obj);\n  } catch {\n    return decodeSanityString(data);\n  }\n}\nexport {\n  DRAFTS_PREFIX,\n  decodeSanityNodeData,\n  decodeSanityString,\n  encodeSanityNodeData,\n  isArray,\n  isRecord,\n  isValidSanityLegacyNode,\n  isValidSanityNode,\n  pathToUrlString,\n  urlStringToPath\n};\n//# sourceMappingURL=transformSanityNodeData.js.map\n"],"names":["pathToUrlString","path","str","segment","value","Array","isArray","join","_key","RE_SEGMENT_WITH_INDEX","RE_SEGMENT_WITH_TUPLE","RE_SEGMENT_WITH_KEY","DRAFTS_PREFIX","lengthyStr","pipe","string","minLength","optionalLengthyStr","optional","sanityNodeSchema","object","baseUrl","dataset","id","projectId","tool","type","workspace","isDraft","sanityLegacyNodeSchema","origin","href","data","record","unknown","isValidSanityNode","node","is","encodeSanityNodeData","_id","getPublishedId","studioPath","fromString","encodeURIComponent","startsWith","filter","map","part","key","decodeSanityString","split","reduce","acc","includes","toString","withIndex","exec","push","Number","withTuple","withKey","urlStringToPath","decodeURIComponent","decodeSanityObject","sanityNode","safeParse","success","output","sanityLegacyNode","url","URL","document","location","searchParams","size","parse","Object","fromEntries","entries","err","console","error","decodeSanityNodeData","JSON"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"file":"mutations.js","sources":["file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/node_modules/.pnpm/%40sanity%2Btypes%403.63.0_debug%404.3.7/node_modules/%40sanity/types/lib/index.mjs","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/node_modules/.pnpm/%40sanity%2Butil%403.63.0_debug%404.3.7/node_modules/%40sanity/util/lib/paths.mjs","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/util/documents.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/ui/optimistic-state/machines/datasetMutatorMachine.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/ui/optimistic-state/context.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/ui/optimistic-state/useOptimisticActor.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/ui/optimistic-state/useDocuments.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/util/randomKey.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/util/mutations.ts"],"sourcesContent":["function isObject(obj) {\n  return typeof obj == \"object\" && obj !== null && !Array.isArray(obj);\n}\nfunction isReference(reference) {\n  return isObject(reference) && typeof reference._ref == \"string\";\n}\nfunction isImage(value) {\n  return isObject(value) && isReference(value.asset) && value.asset._ref.startsWith(\"image-\");\n}\nfunction isCrossDatasetReference(reference) {\n  return isObject(reference) && typeof reference._ref == \"string\" && typeof reference._dataset == \"string\" && typeof reference._projectId == \"string\";\n}\nfunction isSanityDocument(document) {\n  return isObject(document) && typeof document._id == \"string\" && typeof document._type == \"string\";\n}\nfunction isTypedObject(obj) {\n  return isObject(obj) && typeof obj._type == \"string\";\n}\nfunction isKeyedObject(obj) {\n  return isObject(obj) && typeof obj._key == \"string\";\n}\nfunction isValidationErrorMarker(marker) {\n  return marker.level === \"error\";\n}\nfunction isValidationWarningMarker(marker) {\n  return marker.level === \"warning\";\n}\nfunction isValidationInfoMarker(marker) {\n  return marker.level === \"info\";\n}\nfunction isCreateMutation(mutation) {\n  return \"create\" in mutation;\n}\nfunction isCreateIfNotExistsMutation(mutation) {\n  return \"createIfNotExists\" in mutation;\n}\nfunction isCreateOrReplaceMutation(mutation) {\n  return \"createOrReplace\" in mutation;\n}\nfunction isDeleteMutation(mutation) {\n  return \"delete\" in mutation;\n}\nfunction isPatchMutation(mutation) {\n  return \"patch\" in mutation;\n}\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, reIndexTuple = /^\\d*:\\d*$/;\nfunction isIndexSegment(segment) {\n  return typeof segment == \"number\" || typeof segment == \"string\" && /^\\[\\d+\\]$/.test(segment);\n}\nfunction isKeySegment(segment) {\n  return typeof segment == \"string\" ? reKeySegment.test(segment.trim()) : typeof segment == \"object\" && \"_key\" in segment;\n}\nfunction isIndexTuple(segment) {\n  if (typeof segment == \"string\" && reIndexTuple.test(segment))\n    return !0;\n  if (!Array.isArray(segment) || segment.length !== 2)\n    return !1;\n  const [from, to] = segment;\n  return (typeof from == \"number\" || from === \"\") && (typeof to == \"number\" || to === \"\");\n}\nfunction isRecord$1(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isPortableTextTextBlock(value) {\n  return isRecord$1(value) && typeof value._type == \"string\" && // block types can be named, so expect anything here.\n  Array.isArray(value.children) && value.children.every((child) => isRecord$1(child)) && (\"markDefs\" in value ? Array.isArray(value.markDefs) && value.markDefs.every((def) => isRecord$1(def)) : !0) && (\"style\" in value ? typeof value.style == \"string\" : !0);\n}\nfunction isPortableTextSpan(value) {\n  return isRecord$1(value) && value._type === \"span\" && typeof value.text == \"string\" && (\"marks\" in value ? Array.isArray(value.marks) && value.marks.every((mark) => typeof mark == \"string\") : !0);\n}\nfunction isPortableTextListBlock(value) {\n  return isPortableTextTextBlock(value) && \"listItem\" in value && typeof value.listItem == \"string\" && \"level\" in value && Number.isInteger(value.level);\n}\nfunction isRecord(value) {\n  return !!value && (typeof value == \"object\" || typeof value == \"function\");\n}\nfunction isDocumentSchemaType(type) {\n  if (!isObjectSchemaType(type))\n    return !1;\n  let current = type;\n  for (; current; ) {\n    if (current.name === \"document\")\n      return !0;\n    current = current.type;\n  }\n  return !1;\n}\nfunction isObjectSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"object\" : !1;\n}\nfunction isArraySchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"array\" : !1;\n}\nfunction isArrayOfBlocksSchemaType(type) {\n  return isArraySchemaType(type) && type.of.some((memberType) => isBlockSchemaType(memberType));\n}\nfunction isArrayOfObjectsSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every((memberType) => isObjectSchemaType(memberType));\n}\nfunction isArrayOfPrimitivesSchemaType(type) {\n  return isArraySchemaType(type) && type.of.every((memberType) => isPrimitiveSchemaType(memberType));\n}\nfunction isBooleanSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"boolean\" : !1;\n}\nfunction isStringSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"string\" : !1;\n}\nfunction isNumberSchemaType(type) {\n  return isRecord(type) ? type.jsonType === \"number\" : !1;\n}\nfunction isPrimitiveSchemaType(type) {\n  return isBooleanSchemaType(type) || isStringSchemaType(type) || isNumberSchemaType(type);\n}\nfunction isReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"reference\" || isReferenceSchemaType(type.type));\n}\nfunction isImageSchemaType(type) {\n  return isRecord(type) && (type.name === \"image\" || isImageSchemaType(type.type));\n}\nfunction isFileSchemaType(type) {\n  return isRecord(type) && (type.name === \"file\" || isFileSchemaType(type.type));\n}\nfunction isDeprecatedSchemaType(type) {\n  return isRecord(type) ? typeof type.deprecated < \"u\" : !1;\n}\nfunction isDeprecationConfiguration(type) {\n  return isRecord(type) ? typeof type.deprecated < \"u\" : !1;\n}\nfunction isCrossDatasetReferenceSchemaType(type) {\n  return isRecord(type) && (type.name === \"crossDatasetReference\" || isCrossDatasetReferenceSchemaType(type.type));\n}\nfunction isTitledListValue(item) {\n  return typeof item == \"object\" && item !== null && \"title\" in item && \"value\" in item;\n}\nfunction isSpanSchemaType(type) {\n  return isRecord(type) ? Array.isArray(type.annotations) && Array.isArray(type.decorators) : !1;\n}\nfunction isBlockSchemaType(type) {\n  if (!isRecord(type) || !Array.isArray(type.fields)) return !1;\n  const maybeSpanChildren = type.fields.find(isBlockChildrenObjectField), maybeStyle = type.fields.find(isBlockStyleObjectField), maybeList = type.fields.find(isBlockListObjectField);\n  return isBlockChildrenObjectField(maybeSpanChildren) && isBlockStyleObjectField(maybeStyle) && isBlockListObjectField(maybeList);\n}\nfunction isBlockStyleObjectField(field) {\n  return !isRecord(field) || field.name !== \"style\" ? !1 : isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockListObjectField(field) {\n  return !isRecord(field) || field.name !== \"listItem\" ? !1 : isRecord(field.type) && field.type.jsonType === \"string\";\n}\nfunction isBlockChildrenObjectField(field) {\n  return !isRecord(field) || field.name !== \"children\" || !isArraySchemaType(field.type) ? !1 : field.type.of.some(isSpanSchemaType);\n}\nfunction defineType(schemaDefinition, defineOptions) {\n  return schemaDefinition;\n}\nfunction defineField(schemaField, defineOptions) {\n  return schemaField;\n}\nfunction defineArrayMember(arrayOfSchema, defineOptions) {\n  return arrayOfSchema;\n}\nfunction typed(input) {\n  return input;\n}\nfunction isSlug(thing) {\n  return isObject(thing) && typeof thing.current == \"string\";\n}\nfunction isCreateSquashedMutation(mutation) {\n  return \"createSquashed\" in mutation;\n}\nfunction isValidationError(node) {\n  return node.level === \"error\";\n}\nfunction isValidationWarning(node) {\n  return node.level === \"warning\";\n}\nfunction isValidationInfo(node) {\n  return node.level === \"info\";\n}\nexport {\n  defineArrayMember,\n  defineField,\n  defineType,\n  isArrayOfBlocksSchemaType,\n  isArrayOfObjectsSchemaType,\n  isArrayOfPrimitivesSchemaType,\n  isArraySchemaType,\n  isBlockChildrenObjectField,\n  isBlockListObjectField,\n  isBlockSchemaType,\n  isBlockStyleObjectField,\n  isBooleanSchemaType,\n  isCreateIfNotExistsMutation,\n  isCreateMutation,\n  isCreateOrReplaceMutation,\n  isCreateSquashedMutation,\n  isCrossDatasetReference,\n  isCrossDatasetReferenceSchemaType,\n  isDeleteMutation,\n  isDeprecatedSchemaType,\n  isDeprecationConfiguration,\n  isDocumentSchemaType,\n  isFileSchemaType,\n  isImage,\n  isImageSchemaType,\n  isIndexSegment,\n  isIndexTuple,\n  isKeySegment,\n  isKeyedObject,\n  isNumberSchemaType,\n  isObjectSchemaType,\n  isPatchMutation,\n  isPortableTextListBlock,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  isPrimitiveSchemaType,\n  isReference,\n  isReferenceSchemaType,\n  isSanityDocument,\n  isSlug,\n  isSpanSchemaType,\n  isStringSchemaType,\n  isTitledListValue,\n  isTypedObject,\n  isValidationError,\n  isValidationErrorMarker,\n  isValidationInfo,\n  isValidationInfoMarker,\n  isValidationWarning,\n  isValidationWarningMarker,\n  typed\n};\n//# sourceMappingURL=index.mjs.map\n","import { isIndexSegment, isKeySegment, isIndexTuple } from \"@sanity/types\";\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/, EMPTY_PATH = [], FOCUS_TERMINATOR = \"$\", GROQ_DATA_TYPE_VALUES = [\"true\", \"false\", \"null\"];\nfunction get(obj, path, defaultVal) {\n  const select = typeof path == \"string\" ? fromString(path) : path;\n  if (!Array.isArray(select))\n    throw new Error(\"Path must be an array or a string\");\n  let acc = obj;\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i];\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc[segment];\n    }\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc))\n        return defaultVal;\n      acc = acc.find((item) => item._key === segment._key);\n    }\n    if (typeof segment == \"string\" && (acc = typeof acc == \"object\" && acc !== null ? acc[segment] : void 0), typeof acc > \"u\")\n      return defaultVal;\n  }\n  return acc;\n}\nconst pathsMemo = /* @__PURE__ */ new Map();\nfunction pathFor(path) {\n  if (path.length === 0)\n    return EMPTY_PATH;\n  const asString = toString(path);\n  return pathsMemo.has(asString) ? pathsMemo.get(asString) : (pathsMemo.set(asString, path), Object.freeze(path), path);\n}\nfunction isEqual(path, otherPath) {\n  return path.length === otherPath.length && path.every((segment, i) => isSegmentEqual(segment, otherPath[i]));\n}\nfunction numEqualSegments(path, otherPath) {\n  const length = Math.min(path.length, otherPath.length);\n  for (let i = 0; i < length; i++)\n    if (!isSegmentEqual(path[i], otherPath[i]))\n      return i;\n  return length;\n}\nfunction isSegmentEqual(segmentA, segmentB) {\n  return isKeySegment(segmentA) && isKeySegment(segmentB) ? segmentA._key === segmentB._key : isIndexSegment(segmentA) ? Number(segmentA) === Number(segmentB) : isIndexTuple(segmentA) && isIndexTuple(segmentB) ? segmentA[0] === segmentB[0] && segmentA[1] === segmentB[1] : segmentA === segmentB;\n}\nfunction hasFocus(focusPath, path) {\n  const withoutTerminator = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;\n  return isEqual(withoutTerminator, path);\n}\nfunction hasItemFocus(focusPath, item) {\n  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);\n}\nfunction isExpanded(segment, focusPath) {\n  const [head, ...tail] = focusPath;\n  return tail.length > 0 && isSegmentEqual(segment, head);\n}\nfunction startsWith(prefix, path) {\n  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]));\n}\nfunction trimLeft(prefix, path) {\n  if (prefix.length === 0 || path.length === 0)\n    return path;\n  const [prefixHead, ...prefixTail] = prefix, [pathHead, ...pathTail] = path;\n  return isSegmentEqual(prefixHead, pathHead) ? pathFor(trimLeft(prefixTail, pathTail)) : path;\n}\nfunction trimRight(suffix, path) {\n  const sufLen = suffix.length, pathLen = path.length;\n  if (sufLen === 0 || pathLen === 0)\n    return path;\n  let i = 0;\n  for (; i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1]); )\n    i++;\n  return pathFor(path.slice(0, pathLen - i));\n}\nfunction trimChildPath(path, childPath) {\n  return startsWith(path, childPath) ? trimLeft(path, childPath) : EMPTY_PATH;\n}\nfunction toString(path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return path.reduce((target, segment, i) => {\n    const isHead = i === 0;\n    if (typeof segment == \"number\")\n      return `${target}[${segment}]`;\n    if (typeof segment == \"string\")\n      return isHead ? segment : GROQ_DATA_TYPE_VALUES.includes(segment) ? `${target}[\"${segment}\"]` : `${target}.${segment}`;\n    if (isKeySegment(segment) && segment._key)\n      return `${target}[_key==\"${segment._key}\"]`;\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return `${target}[${from}:${to}]`;\n    }\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``);\n  }, \"\");\n}\nfunction _resolveKeyedPath(value, path) {\n  if (path.length === 0)\n    return path;\n  const [next, ...rest] = path;\n  if (typeof next == \"number\") {\n    if (!Array.isArray(value) || !(next in value))\n      return [];\n    const item = value[next];\n    return [typeof item?._key == \"string\" ? { _key: item._key } : next, ..._resolveKeyedPath(item, rest)];\n  }\n  const nextVal = get(value, [next]);\n  return [next, ..._resolveKeyedPath(nextVal, rest)];\n}\nfunction resolveKeyedPath(value, path) {\n  if (!Array.isArray(path))\n    throw new Error(\"Path is not an array\");\n  return pathFor(_resolveKeyedPath(value, path));\n}\nfunction fromString(path) {\n  if (typeof path != \"string\")\n    throw new Error(\"Path is not a string\");\n  const segments = path.match(rePropName);\n  if (!segments)\n    throw new Error(\"Invalid path string\");\n  return segments.map(normalizePathSegment);\n}\nfunction normalizePathSegment(segment) {\n  return isIndexSegment(segment) ? normalizeIndexSegment(segment) : isKeySegment(segment) ? normalizeKeySegment(segment) : isIndexTuple(segment) ? normalizeIndexTupleSegment(segment) : segment;\n}\nfunction normalizeIndexSegment(segment) {\n  return Number(segment.replace(/[^\\d]/g, \"\"));\n}\nfunction normalizeKeySegment(segment) {\n  return { _key: segment.match(reKeySegment)[1] };\n}\nfunction normalizeIndexTupleSegment(segment) {\n  const [from, to] = segment.split(\":\").map((seg) => seg === \"\" ? seg : Number(seg));\n  return [from, to];\n}\nexport {\n  FOCUS_TERMINATOR,\n  _resolveKeyedPath,\n  fromString,\n  get,\n  hasFocus,\n  hasItemFocus,\n  isEqual,\n  isExpanded,\n  isSegmentEqual,\n  numEqualSegments,\n  pathFor,\n  resolveKeyedPath,\n  startsWith,\n  toString,\n  trimChildPath,\n  trimLeft,\n  trimRight\n};\n//# sourceMappingURL=paths.mjs.map\n","import {DRAFTS_PREFIX} from '@repo/visual-editing-helpers/csm'\n\nexport function isDraftId(id: string): boolean {\n  return id.startsWith(DRAFTS_PREFIX)\n}\n\nexport function getDraftId(id: string): string {\n  return isDraftId(id) ? id : DRAFTS_PREFIX + id\n}\n\nexport function getPublishedId(id: string): string {\n  return isDraftId(id) ? id.slice(DRAFTS_PREFIX.length) : id\n}\n","/**\n * The logic here is intended to live inside a preview iframe, and listen to events from the parent frame.\n * It also supports running in a \"detached\" mode, where it has to setup authenticated EventSource conenctions and perform data fetching itself.\n */\n\nimport {type SanityClient} from '@sanity/client'\nimport {\n  createSharedListener,\n  documentMutatorMachine,\n  type DocumentMutatorMachineInput,\n  type DocumentMutatorMachineParentEvent,\n} from '@sanity/mutate/_unstable_machine'\nimport {assertEvent, assign, emit, setup, stopChild, type ActorRefFrom} from 'xstate'\n\nexport interface DatasetMutatorMachineInput extends Omit<DocumentMutatorMachineInput, 'id'> {\n  client: SanityClient\n  /** A shared listener can be provided, if not it'll be created using `client.listen()` */\n  sharedListener?: ReturnType<typeof createSharedListener>\n}\n\nexport const datasetMutatorMachine = setup({\n  types: {} as {\n    context: {\n      client: SanityClient\n      /** A shared listener can be provided, if not it'll be created using `client.listen()` */\n      sharedListener?: ReturnType<typeof createSharedListener>\n      documents: Record<string, ActorRefFrom<typeof documentMutatorMachine>>\n    }\n    events:\n      | {type: 'observe'; documentId: string}\n      | {type: 'unobserve'; documentId: string}\n      | {type: 'add document actor'; documentId: string}\n      | {type: 'stop document actor'; documentId: string}\n      | DocumentMutatorMachineParentEvent\n    input: DatasetMutatorMachineInput\n    emitted: DocumentMutatorMachineParentEvent\n  },\n  actions: {\n    'emit sync event': emit(({event}) => {\n      assertEvent(event, 'sync')\n      return event\n    }),\n    'emit mutation event': emit(({event}) => {\n      assertEvent(event, 'mutation')\n      return event\n    }),\n    'emit rebased event': emit(({event}) => {\n      assertEvent(event, ['rebased.local', 'rebased.remote'])\n      return event\n    }),\n    'emit pristine event': emit(({event}) => {\n      assertEvent(event, ['pristine'])\n      return event\n    }),\n    'add document actor': assign({\n      documents: ({context, event, spawn}) => {\n        assertEvent(event, 'observe')\n        const id = event.documentId\n        // Adding the same documentId multiple times is a no-op\n        if (context.documents[id]) return context.documents\n        return {\n          ...context.documents,\n          [id]: spawn('documentMutatorMachine', {\n            input: {\n              id,\n              client: context.client,\n              sharedListener: context.sharedListener || createSharedListener(context.client),\n            },\n            id,\n          }),\n        }\n      },\n    }),\n    'stop remote snapshot': stopChild(({context, event}) => {\n      assertEvent(event, 'unobserve')\n      return context.documents[event.documentId]!\n    }),\n    'remove remote snapshot from context': assign({\n      documents: ({context, event}) => {\n        assertEvent(event, 'unobserve')\n        // Removing a non-existing documentId is a no-op\n        if (!context.documents[event.documentId]) return context.documents\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const {[event.documentId]: _, ...documents} = context.documents\n        return documents\n      },\n    }),\n  },\n  actors: {\n    documentMutatorMachine,\n  },\n}).createMachine({\n  /** @xstate-layout N4IgpgJg5mDOIC5QBsD2BjAhsgIhgrgLZgB2ALgMTICWsZpA2gAwC6ioADqrNWdaiXYgAHogC0ADgBMAOgkA2ACyKArBICcTdfKXSANCACeiFQHYZpgMxWV800yYqp6gIyn5AXw8G0WXAWJyCnwSGjpGViEuHj4BIVEEKUt5OSlFU1smFwkFW0sDY0T1GRUXRXkXKVN7HSYJJkUvHwxsPHQiUjIZDgAnWj4SMApCfDJMemY2JBBo3n5BaYSXeVlbKRUsiXdFSxcXfKNERSqZTbr1zVMJNyaQX1aAzpkIah6yQwp0VEJCXkmo7hzOKLRDLFwyFxaSzXKTOKQudSKCQFRDOczqCSWJjwjbHCQqRFebwgEioCBwIT3fztQJkAExebxcQuFEIZaWGRIrF7dSXKTyFSNYlUtodcjdPp0aiDelAhagBLpVmWAmc46mNwSZTyLQuFS3EWPcUvN6FTiA2LykSoq6c6wbCqVUzparKioyRFVfkq1zqNSWIkeIA */\n  id: 'dataset-mutator',\n  context: ({input}) => ({\n    documents: {},\n    client: input.client,\n    sharedListener: input.sharedListener,\n  }),\n\n  on: {\n    'sync': {actions: ['emit sync event']},\n    'mutation': {actions: ['emit mutation event']},\n    'rebased.*': {actions: ['emit rebased event']},\n    'pristine': {actions: ['emit pristine event']},\n    'observe': {\n      actions: ['add document actor'],\n    },\n    'unobserve': {\n      actions: ['stop remote snapshot', 'remove remote snapshot from context'],\n    },\n  },\n\n  initial: 'pristine',\n\n  states: {\n    pristine: {},\n  },\n})\n","import {createEmptyActor, type ActorRefFrom} from 'xstate'\nimport {createDatasetMutator} from '../comlink'\n\nexport type MutatorActor = ActorRefFrom<ReturnType<typeof createDatasetMutator>>\nexport type EmptyActor = typeof emptyActor\n\nexport const emptyActor = createEmptyActor()\n\nexport let actor: MutatorActor | EmptyActor = emptyActor\n\nexport const listeners = new Set<() => void>()\n\nexport function isEmptyActor(actor: MutatorActor | EmptyActor): actor is EmptyActor {\n  return actor === emptyActor\n}\n\nexport function setActor(nextActor: MutatorActor): void {\n  actor = nextActor\n  for (const onActorChange of listeners) {\n    onActorChange()\n  }\n}\n","import {useCallback, useMemo, useSyncExternalStore} from 'react'\nimport {\n  actor,\n  emptyActor,\n  isEmptyActor,\n  listeners,\n  type EmptyActor,\n  type MutatorActor,\n} from './context'\n\nexport function useOptimisticActor(): MutatorActor | EmptyActor {\n  const subscribe = useCallback((listener: () => void) => {\n    listeners.add(listener)\n    return () => listeners.delete(listener)\n  }, [])\n\n  const actorRef = useSyncExternalStore(\n    subscribe,\n    () => actor,\n    () => emptyActor,\n  )\n\n  return actorRef\n}\n\nexport function useOptimisticActorReady(): boolean {\n  const actor = useOptimisticActor()\n  return useMemo(() => !isEmptyActor(actor), [actor])\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type {SanityDocument} from '@sanity/client'\nimport {createIfNotExists, patch, type Mutation, type NodePatchList} from '@sanity/mutate'\nimport {get as getAtPath} from '@sanity/util/paths'\nimport {useCallback} from 'react'\nimport {getDraftId, getPublishedId} from '../../util/documents'\nimport type {MutatorActor} from './context'\nimport {isEmptyActor} from './context'\nimport {useOptimisticActor} from './useOptimisticActor'\n\nexport type Path<T, K extends keyof T> = K extends string\n  ? T[K] extends Record<string, any>\n    ? `${K}.${Path<T[K], keyof T[K]>}` | K\n    : K\n  : never\n\nexport type PathValue<T, P extends string> = P extends `${infer K}.${infer Rest}`\n  ? K extends keyof T\n    ? PathValue<T[K], Rest>\n    : never\n  : P extends keyof T\n    ? T[P]\n    : never\n\nexport type DocumentsMutate = (\n  documentId: string,\n  mutations: Mutation[],\n  options?: {commit?: boolean | {debounce: number}},\n) => void\n\nexport type DocumentsGet = <T extends Record<string, any>>(\n  documentId: string,\n) => OptimisticDocument<T>\n\nexport type OptimisticDocument<T extends Record<string, any> = Record<string, any>> = {\n  id: string\n  commit: () => void\n  get: {\n    (): SanityDocument<T> | undefined\n    <P extends Path<T, keyof T>>(path: P): PathValue<T, P> | undefined\n  }\n  patch: (\n    patches:\n      | ((context: {\n          draftId: string\n          publishedId: string\n          snapshot: SanityDocument<T>\n        }) => NodePatchList)\n      | NodePatchList,\n    options?: {commit?: boolean | {debounce: number}},\n  ) => void\n}\n\nfunction debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(fn: F, timeout: number): F {\n  let timer: ReturnType<typeof setTimeout>\n  return ((...args: Parameters<F>) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      fn.apply(fn, args)\n    }, timeout)\n  }) as F\n}\n\nfunction getDocumentsAndSnapshot<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  const inFrame = window.self !== window.top || window.opener\n\n  if (isEmptyActor(actor) || !inFrame) {\n    throw new Error('The `useDocuments` hook cannot be used in this context')\n  }\n\n  const draftId = getDraftId(id)\n  const publishedId = getPublishedId(id)\n  const documents = actor.getSnapshot().context?.documents\n\n  const draftDoc = documents?.[draftId]\n  const publishedDoc = documents?.[publishedId]\n\n  if (!draftDoc) {\n    throw new Error(`Document \"${id}\" not found`)\n  }\n\n  // Get the snapshot from the draft document if it exists, otherwise fall\n  // back to the published document\n  const snapshot = (draftDoc?.getSnapshot().context?.local ||\n    publishedDoc?.getSnapshot().context?.local) as unknown as SanityDocument<T> | undefined\n\n  if (!snapshot) {\n    throw new Error(`Snapshot for document \"${id}\" not found`)\n  }\n\n  return {draftId, publishedId, draftDoc, publishedDoc, snapshot}\n}\n\nfunction createDocumentCommit<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return (): void => {\n    const {draftDoc} = getDocumentsAndSnapshot<T>(id, actor)\n    draftDoc.send({type: 'submit'})\n  }\n}\n\nfunction createDocumentGet<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return <P extends Path<T, keyof T>>(\n    path?: P,\n  ): PathValue<T, P> | SanityDocument<T> | undefined => {\n    const {snapshot} = getDocumentsAndSnapshot<T>(id, actor)\n\n    return path\n      ? (getAtPath(snapshot, path) as PathValue<T, P>)\n      : (snapshot as unknown as SanityDocument<T>)\n  }\n}\n\nfunction createDocumentPatch<T extends Record<string, any>>(id: string, actor: MutatorActor) {\n  return (\n    patches:\n      | ((context: {\n          draftId: string\n          publishedId: string\n          snapshot: SanityDocument<T>\n        }) => NodePatchList)\n      | NodePatchList,\n    options?: {commit?: boolean | {debounce: number}},\n  ): void => {\n    const {draftDoc, draftId, publishedId, snapshot} = getDocumentsAndSnapshot<T>(id, actor)\n\n    const {commit = true} = options || {}\n\n    const context = {\n      draftId,\n      publishedId,\n      snapshot,\n    }\n\n    const resolvedPatches = typeof patches === 'function' ? patches(context) : patches\n\n    draftDoc.send({\n      type: 'mutate',\n      mutations: [\n        // Attempt to create the draft document, it might not exist if the\n        // snapshot was from the published document\n        createIfNotExists({...snapshot, _id: draftId}),\n        // Patch the draft document with the resolved patches\n        patch(draftId, resolvedPatches),\n      ],\n    })\n\n    if (commit) {\n      if (typeof commit === 'object' && 'debounce' in commit) {\n        const debouncedCommit = debounce(() => draftDoc.send({type: 'submit'}), commit.debounce)\n        debouncedCommit()\n      } else {\n        draftDoc.send({type: 'submit'})\n      }\n    }\n  }\n}\n\nexport function useDocuments(): {\n  getDocument: DocumentsGet\n  mutateDocument: DocumentsMutate\n} {\n  const actor = useOptimisticActor() as MutatorActor\n\n  const getDocument: DocumentsGet = useCallback(\n    <T extends Record<string, any>>(documentId: string) => {\n      return {\n        id: documentId,\n        commit: createDocumentCommit(documentId, actor),\n        get: createDocumentGet(documentId, actor),\n        patch: createDocumentPatch<T>(documentId, actor),\n      }\n    },\n    [actor],\n  )\n\n  const mutateDocument: DocumentsMutate = useCallback(\n    (id, mutations, options) => {\n      const {draftDoc} = getDocumentsAndSnapshot(id, actor)\n      const {commit = true} = options || {}\n\n      draftDoc.send({\n        type: 'mutate',\n        mutations: mutations,\n      })\n\n      if (commit) {\n        if (typeof commit === 'object' && 'debounce' in commit) {\n          const debouncedCommit = debounce(() => draftDoc.send({type: 'submit'}), commit.debounce)\n          debouncedCommit()\n        } else {\n          draftDoc.send({type: 'submit'})\n        }\n      }\n    },\n    [actor],\n  )\n\n  return {getDocument, mutateDocument}\n}\n","import getRandomValues from 'get-random-values-esm'\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nconst getByteHexTable = (() => {\n  let table: string[]\n  return () => {\n    if (table) {\n      return table\n    }\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\nexport function randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import type {SanityNode} from '@repo/visual-editing-helpers'\nimport type {SanityDocument} from '@sanity/client'\nimport {at, insert, truncate, type NodePatchList} from '@sanity/mutate'\nimport {get} from '@sanity/util/paths'\nimport type {OptimisticDocument} from '../ui/optimistic-state'\nimport {randomKey} from './randomKey'\n\nexport function getArrayItemKeyAndParentPath(pathOrNode: string | SanityNode): {\n  path: string\n  key: string\n  hasExplicitKey: boolean\n} {\n  const elementPath = typeof pathOrNode === 'string' ? pathOrNode : pathOrNode.path\n\n  const lastDotIndex = elementPath.lastIndexOf('.')\n  const lastPathItem = elementPath.substring(lastDotIndex + 1, elementPath.length)\n\n  if (!lastPathItem.indexOf('[')) throw new Error('Invalid path: not an array')\n\n  const lastArrayIndex = elementPath.lastIndexOf('[')\n  const path = elementPath.substring(0, lastArrayIndex)\n\n  let key\n  let hasExplicitKey\n\n  if (lastPathItem.includes('_key')) {\n    // explicit [_key=\"...\"]\n\n    const startIndex = lastPathItem.indexOf('\"') + 1\n    const endIndex = lastPathItem.indexOf('\"', startIndex)\n\n    key = lastPathItem.substring(startIndex, endIndex)\n\n    hasExplicitKey = true\n  } else {\n    // indexes [int]\n    const startIndex = lastPathItem.indexOf('[') + 1\n    const endIndex = lastPathItem.indexOf(']', startIndex)\n\n    key = lastPathItem.substring(startIndex, endIndex)\n\n    hasExplicitKey = false\n  }\n\n  if (!path || !key) throw new Error('Invalid path')\n\n  return {\n    path,\n    key,\n    hasExplicitKey,\n  }\n}\n\nexport function getArrayDuplicatePatches(\n  node: SanityNode,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  snapshot: SanityDocument<Record<string, any>>,\n  position: 'before' | 'after' = 'after',\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n\n  const item = get(snapshot, node.path) as object\n  const duplicate = {...item, _key: randomKey()}\n\n  return [at(arrayPath, insert(duplicate, position, {_key: itemKey}))]\n}\n\nexport function getArrayRemovePatches(\n  node: SanityNode,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  snapshot: SanityDocument<Record<string, any>>,\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n  const array = get(snapshot, arrayPath) as {_key: string}[]\n  const currentIndex = array.findIndex((item) => item._key === itemKey)\n  return [at(arrayPath, truncate(currentIndex, currentIndex + 1))]\n}\n\nexport function getArrayInsertPatches(\n  node: SanityNode,\n  insertType: string,\n  position: 'before' | 'after',\n): NodePatchList {\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n  const insertKey = randomKey()\n  const referenceItem = {_key: itemKey}\n  return [at(arrayPath, insert([{_type: insertType, _key: insertKey}], position, referenceItem))]\n}\n\nexport function getArrayMovePatches(\n  node: SanityNode,\n  doc: OptimisticDocument,\n  moveTo: 'previous' | 'next' | 'first' | 'last',\n): NodePatchList {\n  if (!node.type) throw new Error('Node type is missing')\n  const {path: arrayPath, key: itemKey} = getArrayItemKeyAndParentPath(node)\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore - Type instantiation is excessively deep and possibly infinite.\n  const array = doc.get(arrayPath) as {_key: string}[]\n  const item = doc.get(node.path)\n  const currentIndex = array.findIndex((item) => item._key === itemKey)\n\n  let nextIndex = -1\n  let position: 'before' | 'after' = 'before'\n\n  if (moveTo === 'first') {\n    if (currentIndex === 0) return []\n    nextIndex = 0\n    position = 'before'\n  } else if (moveTo === 'last') {\n    if (currentIndex === array.length - 1) return []\n    nextIndex = -1\n    position = 'after'\n  } else if (moveTo === 'next') {\n    if (currentIndex === array.length - 1) return []\n    nextIndex = currentIndex\n    position = 'after'\n  } else if (moveTo === 'previous') {\n    if (currentIndex === 0) return []\n    nextIndex = currentIndex - 1\n    position = 'before'\n  }\n\n  return [\n    at(arrayPath, truncate(currentIndex, currentIndex + 1)),\n    at(arrayPath, insert(item, position, nextIndex)),\n  ]\n}\n"],"names":["createIfNotExists","patch","at","insert","truncate","useCallback","useSyncExternalStore","useMemo","DRAFTS_PREFIX","setup","emit","assertEvent","assign","stopChild","createEmptyActor","createSharedListener","documentMutatorMachine","getRandomValues","reKeySegment","reIndexTuple","isIndexSegment","segment","test","isKeySegment","trim","rePropName","get","obj","path","defaultVal","select","Error","segments","match","map","normalizePathSegment","fromString","Array","isArray","acc","i","length","find","item","_key","Number","replace","normalizeIndexSegment","normalizeKeySegment","from","to","isIndexTuple","split","seg","normalizeIndexTupleSegment","isDraftId","id","startsWith","getDraftId","getPublishedId","slice","datasetMutatorMachine","types","actions","event","documents","context","spawn","documentId","input","client","sharedListener","_","actors","createMachine","on","sync","mutation","pristine","observe","unobserve","initial","states","emptyActor","actor","listeners","Set","isEmptyActor","setActor","nextActor","onActorChange","useOptimisticActor","subscribe","listener","add","delete","useOptimisticActorReady","debounce","fn","timeout","timer","args","clearTimeout","setTimeout","apply","getDocumentsAndSnapshot","inFrame","window","self","top","opener","draftId","publishedId","getSnapshot","draftDoc","publishedDoc","snapshot","local","createDocumentCommit","send","type","createDocumentGet","getAtPath","createDocumentPatch","patches","options","commit","resolvedPatches","mutations","_id","useDocuments","getDocument","mutateDocument","getByteHexTable","table","toString","randomKey","rnds8","Uint8Array","whatwgRNG","reduce","str","n","getArrayItemKeyAndParentPath","pathOrNode","elementPath","lastDotIndex","lastIndexOf","lastPathItem","substring","indexOf","lastArrayIndex","key","hasExplicitKey","includes","startIndex","endIndex","getArrayDuplicatePatches","node","position","arrayPath","itemKey","duplicate","getArrayRemovePatches","currentIndex","findIndex","getArrayInsertPatches","insertType","insertKey","_type","getArrayMovePatches","doc","moveTo","array","nextIndex"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8]}},
    {"offset": {"line": 535, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 541, "column": 0}, "map": {"version":3,"file":"SharedStateContext.js","sources":["file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/node_modules/.pnpm/uuid%4010.0.0/node_modules/uuid/dist/esm-browser/stringify.js","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/node_modules/.pnpm/uuid%4010.0.0/node_modules/uuid/dist/esm-browser/rng.js","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/node_modules/.pnpm/uuid%4010.0.0/node_modules/uuid/dist/esm-browser/native.js","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/node_modules/.pnpm/uuid%4010.0.0/node_modules/uuid/dist/esm-browser/v4.js","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/util/geometry.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/util/dragAndDrop.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/util/elements.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/constants.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/util/stega.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/util/findSanityNodes.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/controller.ts","file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing/src/ui/shared-state/SharedStateContext.ts"],"sourcesContent":["import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  var uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n  return getRandomValues(rnds8);\n}","var randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return unsafeStringify(rnds);\n}\nexport default v4;","import type {OverlayRect, Point2D, Ray2D} from '../types'\n\nexport function getRect(element: Element): OverlayRect {\n  const domRect = element.getBoundingClientRect()\n\n  const rect = {\n    x: domRect.x + scrollX,\n    y: domRect.y + scrollY,\n    w: domRect.width,\n    h: domRect.height,\n  }\n\n  return rect\n}\n\nexport function offsetRect(rect: OverlayRect, px: number, axis: 'x' | 'y'): OverlayRect {\n  if (axis === 'x') {\n    return {\n      x: rect.x + px,\n      y: rect.y,\n      w: rect.w - 2 * px,\n      h: rect.h,\n    }\n  } else {\n    return {\n      x: rect.x,\n      y: rect.y + px,\n      w: rect.w,\n      h: rect.h - 2 * px,\n    }\n  }\n}\n\n// Ref http://paulbourke.net/geometry/pointlineplane/\nexport function rayIntersect(l1: Ray2D, l2: Ray2D): Point2D | false {\n  const {x1, y1, x2, y2} = l1\n  const {x1: x3, y1: y3, x2: x4, y2: y4} = l2\n\n  // Check if none of the lines are of length 0\n  if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {\n    return false\n  }\n\n  const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1)\n\n  // Lines are parallel\n  if (denominator === 0) {\n    return false\n  }\n\n  const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator\n  const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator\n\n  // is the intersection along the segments\n  if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n    return false\n  }\n\n  const x = x1 + ua * (x2 - x1)\n  const y = y1 + ua * (y2 - y1)\n\n  return {x, y}\n}\n\nexport function rectEqual(r1: OverlayRect, r2: OverlayRect): boolean {\n  return r1.x === r2.x && r1.y === r2.y && r1.w === r2.w && r1.h === r2.h\n}\n\nexport function rayRectIntersections(line: Ray2D, rect: OverlayRect): Array<Point2D> | false {\n  const rectLines: Array<Ray2D> = [\n    {x1: rect.x, y1: rect.y, x2: rect.x + rect.w, y2: rect.y},\n    {\n      x1: rect.x + rect.w,\n      y1: rect.y,\n      x2: rect.x + rect.w,\n      y2: rect.y + rect.h,\n    },\n    {\n      x1: rect.x + rect.w,\n      y1: rect.y + rect.h,\n      x2: rect.x,\n      y2: rect.y + rect.h,\n    },\n    {\n      x1: rect.x,\n      y1: rect.y + rect.h,\n      x2: rect.x,\n      y2: rect.y,\n    },\n  ]\n\n  const intersections: Array<Point2D> = []\n\n  for (let i = 0; i < rectLines.length; i++) {\n    const intersection = rayIntersect(line, rectLines[i])\n\n    if (intersection) {\n      let isDuplicate = false\n\n      for (let j = 0; j < intersections.length; j++) {\n        if (intersections[j].x === intersection.x && intersections[j].y === intersection.y) {\n          isDuplicate = true\n        }\n      }\n\n      if (!isDuplicate) intersections.push(intersection)\n    }\n  }\n\n  if (intersections.length === 0) {\n    return false\n  }\n\n  return intersections.sort(\n    (a, b) => pointDist(a, {x: line.x1, y: line.y1}) - pointDist(b, {x: line.x1, y: line.y1}),\n  )\n}\nexport function pointDist(p1: Point2D, p2: Point2D): number {\n  const a = p1.x - p2.x\n  const b = p1.y - p2.y\n\n  return Math.sqrt(a * a + b * b)\n}\n\nexport function pointInBounds(point: Point2D, bounds: OverlayRect): boolean {\n  const withinX = point.x >= bounds.x && point.x <= bounds.x + bounds.w\n  const withinY = point.y >= bounds.y && point.y <= bounds.y + bounds.h\n\n  return withinX && withinY\n}\n\nexport function findClosestIntersection(\n  ray: Ray2D,\n  targets: OverlayRect[],\n  flow: string,\n): OverlayRect | null {\n  const rayOrigin = {\n    x: ray.x1,\n    y: ray.y1,\n  }\n\n  // Offset rects to ensure raycasting works when siblings touch\n  if (\n    targets.some((t) =>\n      pointInBounds(\n        rayOrigin,\n        offsetRect(t, Math.min(t.w, t.h) / 10, flow === 'horizontal' ? 'x' : 'y'),\n      ),\n    )\n  )\n    return null\n  let closestIntersection\n  let closestRect\n\n  for (const target of targets) {\n    const intersections = rayRectIntersections(\n      ray,\n      offsetRect(target, Math.min(target.w, target.h) / 10, flow === 'horizontal' ? 'x' : 'y'),\n    )\n    if (intersections) {\n      const firstIntersection = intersections[0]\n\n      if (closestIntersection) {\n        if (pointDist(rayOrigin, firstIntersection) < pointDist(rayOrigin, closestIntersection)) {\n          closestIntersection = firstIntersection\n          closestRect = target\n        }\n      } else {\n        closestIntersection = firstIntersection\n        closestRect = target\n      }\n    }\n  }\n\n  if (closestRect) return closestRect\n\n  return null\n}\n\nexport function scaleRect(\n  rect: OverlayRect,\n  scale: number,\n  origin: {x: number; y: number},\n): OverlayRect {\n  const {x, y, w, h} = rect\n  const {x: originX, y: originY} = origin\n\n  const newX = originX + (x - originX) * scale\n  const newY = originY + (y - originY) * scale\n\n  const newWidth = w * scale\n  const newHeight = h * scale\n\n  return {\n    x: newX,\n    y: newY,\n    w: newWidth,\n    h: newHeight,\n  }\n}\n\nexport function getRectGroupXExtent(rects: OverlayRect[]): {\n  min: number\n  max: number\n  width: number\n} {\n  const minGroupX = Math.max(0, Math.min(...rects.map((r) => r.x)))\n  const maxGroupX = Math.min(document.body.offsetWidth, Math.max(...rects.map((r) => r.x + r.w)))\n\n  return {\n    min: minGroupX,\n    max: maxGroupX,\n    width: maxGroupX - minGroupX,\n  }\n}\n\nexport function getRectGroupYExtent(rects: OverlayRect[]): {\n  min: number\n  max: number\n  height: number\n} {\n  const minGroupY = Math.max(0, Math.min(...rects.map((r) => r.y)))\n  const maxGroupY = Math.min(document.body.scrollHeight, Math.max(...rects.map((r) => r.y + r.h)))\n\n  return {\n    min: minGroupY,\n    max: maxGroupY,\n    height: maxGroupY - minGroupY,\n  }\n}\n","import type {\n  DragInsertPosition,\n  DragInsertPositionRects,\n  ElementNode,\n  OverlayElement,\n  OverlayEventHandler,\n  OverlayRect,\n  Point2D,\n  SanityNode,\n} from '../types'\nimport {\n  findClosestIntersection,\n  getRect,\n  getRectGroupXExtent,\n  getRectGroupYExtent,\n  pointDist,\n  rectEqual,\n  scaleRect,\n} from './geometry'\n\nfunction calcTargetFlow(targets: OverlayRect[]) {\n  if (\n    targets.some((t1) => {\n      const others = targets.filter((t2) => !rectEqual(t1, t2))\n\n      return others.some((t2) => {\n        return t1.y === t2.y\n      })\n    })\n  ) {\n    return 'horizontal'\n  } else {\n    return 'vertical'\n  }\n}\n\nfunction calcInsertPosition(origin: Point2D, targets: OverlayRect[], flow: string) {\n  if (flow === 'horizontal') {\n    const rayLeft = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x - 100_000_000,\n      y2: origin.y,\n    }\n\n    const rayRight = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x + 100_000_000,\n      y2: origin.y,\n    }\n\n    return {\n      left: findClosestIntersection(rayLeft, targets, flow),\n      right: findClosestIntersection(rayRight, targets, flow),\n    }\n  } else {\n    const rayTop = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x,\n      y2: origin.y - 100_000_000,\n    }\n\n    const rayBottom = {\n      x1: origin.x,\n      y1: origin.y,\n      x2: origin.x,\n      y2: origin.y + 100_000_000,\n    }\n\n    return {\n      top: findClosestIntersection(rayTop, targets, flow),\n      bottom: findClosestIntersection(rayBottom, targets, flow),\n    }\n  }\n}\n\nfunction findRectSanityData(rect: OverlayRect, overlayGroup: OverlayElement[]) {\n  return overlayGroup.find((e) => rectEqual(getRect(e.elements.element), rect))\n    ?.sanity as SanityNode\n}\n\nfunction resolveInsertPosition(\n  overlayGroup: OverlayElement[],\n  insertPosition: DragInsertPositionRects,\n  flow: string,\n): DragInsertPosition {\n  if (Object.values(insertPosition).every((v) => v === null)) return null\n\n  if (flow === 'horizontal') {\n    return {\n      left: insertPosition.left\n        ? {\n            rect: insertPosition.left,\n            sanity: findRectSanityData(insertPosition.left, overlayGroup),\n          }\n        : null,\n      right: insertPosition.right\n        ? {\n            rect: insertPosition.right,\n            sanity: findRectSanityData(insertPosition.right, overlayGroup),\n          }\n        : null,\n    }\n  } else {\n    return {\n      top: insertPosition.top\n        ? {\n            rect: insertPosition.top,\n            sanity: findRectSanityData(insertPosition.top, overlayGroup),\n          }\n        : null,\n      bottom: insertPosition.bottom\n        ? {\n            rect: insertPosition.bottom,\n            sanity: findRectSanityData(insertPosition.bottom, overlayGroup),\n          }\n        : null,\n    }\n  }\n}\n\nfunction calcMousePos(e: MouseEvent) {\n  const bodyBounds = document.body.getBoundingClientRect()\n\n  return {\n    x: Math.max(bodyBounds.x, Math.min(e.clientX, bodyBounds.x + bodyBounds.width)),\n    y: e.clientY + window.scrollY,\n  }\n}\n\nfunction calcMousePosInverseTransform(mousePos: Point2D) {\n  const body = document.body\n  const computedStyle = window.getComputedStyle(body)\n  const transform = computedStyle.transform\n\n  if (transform === 'none') {\n    return {\n      x: mousePos.x,\n      y: mousePos.y,\n    }\n  }\n\n  const matrix = new DOMMatrix(transform)\n  const inverseMatrix = matrix.inverse()\n\n  const point = new DOMPoint(mousePos.x, mousePos.y)\n  const transformedPoint = point.matrixTransform(inverseMatrix)\n\n  return {\n    x: transformedPoint.x,\n    y: transformedPoint.y,\n  }\n}\n\nfunction buildPreviewSkeleton(mousePos: Point2D, element: ElementNode, scaleFactor: number) {\n  const bounds = getRect(element)\n\n  const children = [\n    ...element.querySelectorAll(':where(h1, h2, h3, h4, p, a, img, span, button):not(:has(*))'),\n  ]\n\n  if (mousePos.x <= bounds.x) mousePos.x = bounds.x\n  if (mousePos.x >= bounds.x + bounds.w) mousePos.x = bounds.x + bounds.w\n\n  if (mousePos.y >= bounds.y + bounds.h) mousePos.y = bounds.y + bounds.h\n  if (mousePos.y <= bounds.y) mousePos.y = bounds.y\n\n  const childRects = children.map((child: Element) => {\n    // offset to account for stroke in rendered rects\n    const rect = scaleRect(getRect(child), scaleFactor, {\n      x: bounds.x,\n      y: bounds.y,\n    })\n\n    return {\n      x: rect.x - bounds.x,\n      y: rect.y - bounds.y,\n      w: rect.w,\n      h: rect.h,\n      tagName: child.tagName,\n    }\n  })\n\n  return {\n    offsetX: (bounds.x - mousePos.x) * scaleFactor,\n    offsetY: (bounds.y - mousePos.y) * scaleFactor,\n    w: bounds.w * scaleFactor,\n    h: bounds.h * scaleFactor,\n    maxWidth: bounds.w * scaleFactor * 0.75,\n    childRects,\n  }\n}\n\nconst minDragDelta = 4\n\nasync function applyMinimapWrapperTransform(\n  target: HTMLElement,\n  scaleFactor: number,\n  minYScaled: number,\n  handler: OverlayEventHandler,\n  rectUpdateFrequency: number,\n): Promise<void> {\n  return new Promise((resolve) => {\n    target.addEventListener(\n      'transitionend',\n      () => {\n        setTimeout(() => {\n          handler({\n            type: 'overlay/dragEndMinimapTransition',\n          })\n        }, rectUpdateFrequency * 2)\n\n        resolve()\n      },\n      {once: true},\n    )\n\n    handler({\n      type: 'overlay/dragStartMinimapTransition',\n    })\n\n    handler({\n      type: 'overlay/dragToggleMinimap',\n      display: true,\n    })\n\n    document.body.style.overflow = 'hidden'\n    document.body.style.height = '100%'\n    document.documentElement.style.overflow = 'initial'\n    document.documentElement.style.height = '100%'\n\n    // ensure overflow hidden has applied and scrolling stopped before applying transform, prevent minor y-position transform issues\n    setTimeout(() => {\n      target.style.transformOrigin = '50% 0px'\n      target.style.transition = 'transform 150ms ease'\n      target.style.transform = `translate3d(0px, ${-minYScaled + scrollY}px, 0px) scale(${scaleFactor})`\n    }, 25)\n  })\n}\n\nfunction calcMinimapTransformValues(rects: OverlayRect[], groupHeightOverride: number | null) {\n  let groupHeight = groupHeightOverride || getRectGroupYExtent(rects).height\n\n  const padding = 100 // px\n\n  groupHeight += padding * 2\n\n  const scaleFactor = groupHeight > window.innerHeight ? window.innerHeight / groupHeight : 1\n  const scaledRects = rects.map((r) => scaleRect(r, scaleFactor, {x: window.innerWidth / 2, y: 0}))\n\n  const {min: minYScaled} = getRectGroupYExtent(scaledRects)\n\n  return {\n    scaleFactor,\n    minYScaled: minYScaled - padding * scaleFactor,\n  }\n}\nfunction calcGroupBoundsPreview(rects: OverlayRect[]) {\n  const groupBoundsX = getRectGroupXExtent(rects)\n  const groupBoundsY = getRectGroupYExtent(rects)\n\n  const offsetDist = 8\n\n  const canOffsetX =\n    groupBoundsX.min > offsetDist &&\n    groupBoundsX.min + groupBoundsX.width <= window.innerWidth - offsetDist\n  const canOffsetY =\n    groupBoundsY.min > offsetDist &&\n    groupBoundsY.min + groupBoundsY.height <= document.body.scrollHeight - offsetDist\n  const canOffset = canOffsetX && canOffsetY\n\n  const groupRect = {\n    x: canOffset ? groupBoundsX.min - offsetDist : groupBoundsX.min,\n    y: canOffset ? groupBoundsY.min - offsetDist : groupBoundsY.min,\n    w: canOffset ? groupBoundsX.width + offsetDist * 2 : groupBoundsX.width,\n    h: canOffset ? groupBoundsY.height + offsetDist * 2 : groupBoundsY.height,\n  }\n\n  return groupRect\n}\n\nasync function resetMinimapWrapperTransform(\n  endYOrigin: number,\n  target: HTMLElement,\n  prescaleHeight: number,\n  handler: OverlayEventHandler,\n  rectUpdateFrequency: number,\n  previousRootStyleValues: PreviousRootStyleValues | null,\n): Promise<void> {\n  return new Promise((resolve) => {\n    const computedStyle = window.getComputedStyle(target)\n    const transform = computedStyle.transform\n\n    const matrix = new DOMMatrix(transform)\n\n    const scale = matrix.a\n\n    if (scale === 1) return\n\n    const maxScroll = prescaleHeight - window.innerHeight\n    const prevScrollY = scrollY\n\n    endYOrigin -= window.innerHeight / 2\n\n    if (endYOrigin < 0) endYOrigin = 0\n\n    target.addEventListener(\n      'transitionend',\n      () => {\n        target.style.transition = `none`\n        target.style.transform = `none`\n\n        scrollTo({\n          top: endYOrigin,\n          behavior: 'instant',\n        })\n\n        setTimeout(() => {\n          handler({\n            type: 'overlay/dragEndMinimapTransition',\n          })\n\n          handler({\n            type: 'overlay/dragToggleMinimap',\n            display: false,\n          })\n        }, rectUpdateFrequency * 2)\n\n        resolve()\n      },\n      {once: true},\n    )\n\n    handler({\n      type: 'overlay/dragStartMinimapTransition',\n    })\n\n    target.style.transform = `translateY(${Math.max(prevScrollY - endYOrigin, -maxScroll + prevScrollY)}px) scale(${1})`\n\n    if (!previousRootStyleValues) return\n\n    document.body.style.overflow = previousRootStyleValues.body.overflow\n    document.body.style.height = previousRootStyleValues.body.height\n    document.documentElement.style.overflow = previousRootStyleValues.documentElement.overflow\n    document.documentElement.style.height = previousRootStyleValues.documentElement.height\n  })\n}\n\ninterface PreviousRootStyleValues {\n  body: {\n    overflow: string\n    height: string\n  }\n  documentElement: {\n    overflow: string\n    height: string\n  }\n}\n\ninterface HandleOverlayDragOpts {\n  mouseEvent: MouseEvent\n  element: ElementNode\n  overlayGroup: OverlayElement[]\n  handler: OverlayEventHandler\n  target: SanityNode\n  onSequenceStart: () => void\n  onSequenceEnd: () => void\n}\n\nlet minimapScaleApplied = false\n\nlet mousePosInverseTransform = {x: 0, y: 0}\nlet mousePos = {x: 0, y: 0}\n\nlet prescaleHeight = typeof document === 'undefined' ? 0 : document.documentElement.scrollHeight\n\nlet previousRootStyleValues: PreviousRootStyleValues | null = null\n\nexport function handleOverlayDrag(opts: HandleOverlayDragOpts): void {\n  const {mouseEvent, element, overlayGroup, handler, target, onSequenceStart, onSequenceEnd} = opts\n\n  // do not trigger drag sequence on anything other than \"main\" (0) click, ignore right click, etc\n  if (mouseEvent.button !== 0) return\n\n  // ensure keyboard events fire within frame context\n  window.focus()\n\n  const rectUpdateFrequency = 150\n  let rects = overlayGroup.map((e) => getRect(e.elements.element))\n\n  const flow = (element.getAttribute('data-sanity-drag-flow') || calcTargetFlow(rects)) as\n    | 'horizontal'\n    | 'vertical'\n\n  const dragGroup = element.getAttribute('data-sanity-drag-group')\n\n  const disableMinimap = !!element.getAttribute('data-sanity-drag-minimap-disable')\n\n  const preventInsertDefault = !!element.getAttribute('data-sanity-drag-prevent-default')\n\n  const documentHeightOverride = element.getAttribute('data-unstable_sanity-drag-document-height')\n  const groupHeightOverride = element.getAttribute('data-unstable_sanity-drag-group-height')\n\n  let insertPosition: DragInsertPositionRects | null = null\n\n  const initialMousePos = calcMousePos(mouseEvent)\n\n  const scaleTarget = document.body\n\n  const {minYScaled, scaleFactor} = calcMinimapTransformValues(\n    rects,\n    groupHeightOverride ? ~~groupHeightOverride : null,\n  )\n\n  let sequenceStarted = false\n  let minimapPromptShown = false\n\n  let mousedown = true\n\n  if (!minimapScaleApplied) {\n    previousRootStyleValues = {\n      body: {\n        overflow: window.getComputedStyle(document.body).overflow,\n        height: window.getComputedStyle(document.body).height,\n      },\n      documentElement: {\n        overflow: window.getComputedStyle(document.documentElement).overflow,\n        height: window.getComputedStyle(document.documentElement).height,\n      },\n    }\n\n    prescaleHeight = documentHeightOverride\n      ? ~~documentHeightOverride\n      : document.documentElement.scrollHeight\n  }\n\n  const rectsInterval = setInterval(() => {\n    rects = overlayGroup.map((e) => getRect(e.elements.element))\n  }, rectUpdateFrequency)\n\n  const applyMinimap = (): void => {\n    if (scaleFactor >= 1) return\n\n    const skeleton = buildPreviewSkeleton(mousePos, element, scaleFactor)\n\n    handler({\n      type: 'overlay/dragUpdateSkeleton',\n      skeleton,\n    })\n\n    handler({\n      type: 'overlay/dragToggleMinimapPrompt',\n      display: false,\n    })\n\n    handler({\n      type: 'overlay/dragToggleMinimap',\n      display: true,\n    })\n\n    minimapScaleApplied = true\n\n    applyMinimapWrapperTransform(\n      scaleTarget,\n      scaleFactor,\n      minYScaled,\n      handler,\n      rectUpdateFrequency,\n    ).then(() => {\n      setTimeout(() => {\n        handler({\n          type: 'overlay/dragUpdateGroupRect',\n          groupRect: calcGroupBoundsPreview(rects),\n        })\n      }, rectUpdateFrequency * 2)\n    })\n  }\n\n  const handleScroll = (e: WheelEvent) => {\n    if (\n      Math.abs(e.deltaY) >= 10 &&\n      scaleFactor < 1 &&\n      !minimapScaleApplied &&\n      !minimapPromptShown &&\n      !disableMinimap &&\n      mousedown\n    ) {\n      handler({\n        type: 'overlay/dragToggleMinimapPrompt',\n        display: true,\n      })\n\n      minimapPromptShown = true\n    }\n\n    if (e.shiftKey && !minimapScaleApplied && !disableMinimap) {\n      window.dispatchEvent(new CustomEvent('unstable_sanity/dragApplyMinimap'))\n\n      setTimeout(() => {\n        applyMinimap()\n      }, 50)\n    }\n  }\n\n  const handleMouseMove = (e: MouseEvent): void => {\n    e.preventDefault()\n\n    mousePos = calcMousePos(e)\n    mousePosInverseTransform = calcMousePosInverseTransform(mousePos)\n\n    if (Math.abs(pointDist(mousePos, initialMousePos)) < minDragDelta) return\n\n    if (!sequenceStarted) {\n      const groupRect = calcGroupBoundsPreview(rects)\n\n      const skeleton = buildPreviewSkeleton(mousePos, element, 1)\n\n      handler({\n        type: 'overlay/dragStart',\n        flow,\n      })\n\n      handler({\n        type: 'overlay/dragUpdateSkeleton',\n        skeleton,\n      })\n\n      handler({\n        type: 'overlay/dragUpdateGroupRect',\n        groupRect,\n      })\n\n      sequenceStarted = true\n      onSequenceStart()\n    }\n\n    handler({\n      type: 'overlay/dragUpdateCursorPosition',\n      x: mousePos.x,\n      y: mousePos.y,\n    })\n\n    if (e.shiftKey && !minimapScaleApplied && !disableMinimap) {\n      window.dispatchEvent(new CustomEvent('unstable_sanity/dragApplyMinimap'))\n\n      setTimeout(() => {\n        applyMinimap()\n      }, 50)\n    }\n\n    const newInsertPosition = calcInsertPosition(mousePos, rects, flow)\n\n    if (JSON.stringify(insertPosition) !== JSON.stringify(newInsertPosition)) {\n      insertPosition = newInsertPosition\n\n      handler({\n        type: 'overlay/dragUpdateInsertPosition',\n        insertPosition: resolveInsertPosition(overlayGroup, insertPosition, flow),\n      })\n    }\n  }\n\n  const handleMouseUp = (): void => {\n    mousedown = false\n\n    handler({\n      type: 'overlay/dragEnd',\n      target,\n      insertPosition: insertPosition\n        ? resolveInsertPosition(overlayGroup, insertPosition, flow)\n        : null,\n      dragGroup,\n      flow,\n      preventInsertDefault,\n    })\n\n    if (minimapPromptShown) {\n      handler({\n        type: 'overlay/dragToggleMinimapPrompt',\n        display: false,\n      })\n    }\n\n    if (!minimapScaleApplied) {\n      clearInterval(rectsInterval)\n      onSequenceEnd()\n\n      removeFrameListeners()\n      removeKeyListeners()\n    }\n\n    removeMouseListeners()\n  }\n\n  const handleKeyup = (e: KeyboardEvent) => {\n    if (e.key === 'Shift' && minimapScaleApplied) {\n      minimapScaleApplied = false\n\n      const skeleton = buildPreviewSkeleton(mousePos, element, 1 / scaleFactor)\n\n      handler({\n        type: 'overlay/dragUpdateSkeleton',\n        skeleton,\n      })\n\n      window.dispatchEvent(new CustomEvent('unstable_sanity/dragResetMinimap'))\n\n      setTimeout(() => {\n        resetMinimapWrapperTransform(\n          mousePosInverseTransform.y,\n          scaleTarget,\n          prescaleHeight,\n          handler,\n          rectUpdateFrequency,\n          previousRootStyleValues,\n        )\n      }, 50)\n\n      handler({\n        type: 'overlay/dragUpdateGroupRect',\n        groupRect: null,\n      })\n\n      // cleanup keyup after drag sequence is complete\n      if (!mousedown) {\n        clearInterval(rectsInterval)\n\n        removeMouseListeners()\n        removeFrameListeners()\n        removeKeyListeners()\n\n        onSequenceEnd()\n      }\n    }\n  }\n\n  const handleBlur = () => {\n    handler({\n      type: 'overlay/dragUpdateGroupRect',\n      groupRect: null,\n    })\n\n    window.dispatchEvent(new CustomEvent('unstable_sanity/dragResetMinimap'))\n\n    setTimeout(() => {\n      resetMinimapWrapperTransform(\n        mousePosInverseTransform.y,\n        scaleTarget,\n        prescaleHeight,\n        handler,\n        rectUpdateFrequency,\n        previousRootStyleValues,\n      ).then(() => {\n        minimapScaleApplied = false\n      })\n    }, 50)\n\n    clearInterval(rectsInterval)\n\n    removeMouseListeners()\n    removeFrameListeners()\n    removeKeyListeners()\n\n    onSequenceEnd()\n  }\n\n  const removeMouseListeners = () => {\n    window.removeEventListener('mousemove', handleMouseMove)\n    window.removeEventListener('wheel', handleScroll)\n    window.removeEventListener('mouseup', handleMouseUp)\n  }\n\n  const removeKeyListeners = () => {\n    window.removeEventListener('keyup', handleKeyup)\n  }\n\n  const removeFrameListeners = () => {\n    window.removeEventListener('blur', handleBlur)\n  }\n\n  window.addEventListener('blur', handleBlur)\n  window.addEventListener('keyup', handleKeyup)\n  window.addEventListener('wheel', handleScroll)\n  window.addEventListener('mousemove', handleMouseMove)\n  window.addEventListener('mouseup', handleMouseUp)\n}\n","import type {ElementNode} from '../types'\n\nexport const isElementNode = (target: EventTarget | null): target is ElementNode => {\n  return target instanceof HTMLElement || target instanceof SVGElement\n}\n\nexport function findNonInlineElement(element: ElementNode): ElementNode | null {\n  const {display} = window.getComputedStyle(element)\n\n  if (display !== 'inline') return element\n\n  const parent = element.parentElement\n\n  if (!parent) return null\n\n  return findNonInlineElement(parent)\n}\n\nexport const findOverlayElement = (\n  el: EventTarget | ElementNode | null | undefined,\n): ElementNode | null => {\n  if (!el || !isElementNode(el)) {\n    return null\n  }\n\n  if (el.dataset?.['sanityOverlayElement']) {\n    return el\n  }\n\n  return findOverlayElement(el.parentElement)\n}\n","export {VERCEL_STEGA_REGEX} from '@vercel/stega'\n\nexport const OVERLAY_ID = 'sanity-visual-editing'\n\n/**\n * How long to wait after the last subscriber has unsubscribed before resetting the observable and disconnecting the listener\n * We want to keep the listener alive for a short while after the last subscriber has unsubscribed to avoid unnecessary reconnects\n */\nexport const LISTENER_RESET_DELAY = 2000\n","import type {SanityStegaNode} from '@repo/visual-editing-helpers'\nimport {vercelStegaDecode} from '@vercel/stega'\nimport {VERCEL_STEGA_REGEX} from '../constants'\n\n/**\n * JavaScript regexps are stateful. Have to reset lastIndex between runs to ensure consistent behaviour for the same string\n * @param input\n */\nfunction testVercelStegaRegex(input: string): boolean {\n  VERCEL_STEGA_REGEX.lastIndex = 0\n  return VERCEL_STEGA_REGEX.test(input)\n}\n\nfunction decodeStega(str: string, isAltText = false): SanityStegaNode | null {\n  try {\n    const decoded = vercelStegaDecode<SanityStegaNode>(str)\n    if (!decoded || decoded.origin !== 'sanity.io') {\n      return null\n    }\n    if (isAltText) {\n      decoded.href = decoded.href?.replace('.alt', '')\n    }\n    return decoded\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error('Failed to decode stega for string: ', str, 'with the original error: ', err)\n    return null\n  }\n}\n\nexport function testAndDecodeStega(str: string, isAltText = false): SanityStegaNode | null {\n  if (testVercelStegaRegex(str)) {\n    return decodeStega(str, isAltText)\n  }\n  return null\n}\n","import {decodeSanityNodeData} from '@repo/visual-editing-helpers/csm'\nimport {OVERLAY_ID} from '../constants'\nimport type {\n  ElementNode,\n  OverlayElement,\n  ResolvedElement,\n  SanityNode,\n  SanityStegaNode,\n} from '../types'\nimport {findNonInlineElement} from './elements'\nimport {testAndDecodeStega} from './stega'\n\nconst isElementNode = (node: ChildNode): node is ElementNode => node.nodeType === Node.ELEMENT_NODE\n\nconst isImgElement = (el: ElementNode): el is HTMLImageElement => el.tagName === 'IMG'\n\nconst isTimeElement = (el: ElementNode): el is HTMLTimeElement => el.tagName === 'TIME'\n\nconst isSvgRootElement = (el: ElementNode): el is SVGSVGElement =>\n  el.tagName.toUpperCase() === 'SVG'\n\nexport function isSanityNode(node: SanityNode | SanityStegaNode): node is SanityNode {\n  return 'path' in node\n}\n\n/**\n * Finds commonality between two document paths strings\n * @param first First path to compare\n * @param second Second path to compare\n * @returns A common path\n */\nexport function findCommonPath(first: string, second: string): string {\n  let firstParts = first.split('.')\n  let secondParts = second.split('.')\n  const maxLength = Math.min(firstParts.length, secondParts.length)\n  firstParts = firstParts.slice(0, maxLength).reverse()\n  secondParts = secondParts.slice(0, maxLength).reverse()\n\n  return firstParts\n    .reduce((parts, part, i) => (part === secondParts[i] ? [...parts, part] : []), [] as string[])\n    .reverse()\n    .join('.')\n}\n\n/**\n * Returns common Sanity node data from multiple nodes\n * If document paths are present, tries to resolve a common path\n * @param nodes An array of Sanity nodes\n * @returns A single sanity node or undefined\n * @internal\n */\nexport function findCommonSanityData(\n  nodes: (SanityNode | SanityStegaNode)[],\n): SanityNode | SanityStegaNode | undefined {\n  // If there are no nodes, or inconsistent node types\n  if (!nodes.length || !nodes.map((n) => isSanityNode(n)).every((n, _i, arr) => n === arr[0])) {\n    return undefined\n  }\n  // If legacy nodes, return first match (no common pathfinding)\n  if (!isSanityNode(nodes[0])) return nodes[0]\n\n  const sanityNodes = nodes.filter(isSanityNode)\n  let common: SanityNode | undefined = nodes[0]\n\n  const consistentValueKeys: Array<keyof SanityNode> = [\n    'projectId',\n    'dataset',\n    'id',\n    'baseUrl',\n    'workspace',\n    'tool',\n  ]\n  for (let i = 1; i < sanityNodes.length; i++) {\n    const node = sanityNodes[i]\n    if (consistentValueKeys.some((key) => node[key] !== common?.[key])) {\n      common = undefined\n      break\n    }\n\n    common.path = findCommonPath(common.path, node.path)\n  }\n\n  return common\n}\n\n/**\n * Finds nodes containing sanity specific data\n * @param el - A parent element to traverse\n * @returns An array of objects, each containing an HTML element and decoded sanity data\n * @internal\n */\nexport function findSanityNodes(\n  el: ElementNode | ChildNode | {childNodes: Array<ElementNode>},\n): ResolvedElement[] {\n  const elements: ResolvedElement[] = []\n\n  function addElement(element: ElementNode, data: SanityStegaNode | string) {\n    const sanity = decodeSanityNodeData(data)\n    if (!sanity) {\n      return\n    }\n\n    // resize observer does not fire for non-replaced inline elements https://drafts.csswg.org/resize-observer/#intro\n    const measureElement = findNonInlineElement(element)\n    if (!measureElement) {\n      return\n    }\n\n    elements.push({\n      elements: {\n        element,\n        measureElement,\n      },\n      sanity,\n    })\n  }\n\n  if (el) {\n    for (const node of el.childNodes) {\n      const {nodeType, parentElement, textContent} = node\n      // If an edit target is found, find common paths\n      if (isElementNode(node) && node.dataset?.['sanityEditTarget'] !== undefined) {\n        const nodesInTarget = findSanityNodes(node).map(({sanity}) => sanity)\n        // If there are inconsistent node types, continue\n        if (!nodesInTarget.map((n) => isSanityNode(n)).every((n, _i, arr) => n === arr[0])) {\n          continue\n        }\n\n        const commonData = findCommonSanityData(nodesInTarget)\n\n        if (commonData) {\n          elements.push({\n            elements: {\n              element: node,\n              measureElement: node,\n            },\n            sanity: commonData,\n          })\n        }\n\n        // Check non-empty, child-only text nodes for stega strings\n      } else if (nodeType === Node.TEXT_NODE && parentElement && textContent) {\n        const data = testAndDecodeStega(textContent)\n        if (!data) continue\n        addElement(parentElement, data)\n      }\n      // Check element nodes for data attributes, alt tags, etc\n      else if (isElementNode(node)) {\n        // Do not traverse script tags\n        // Do not traverse the visual editing overlay\n        if (node.tagName === 'SCRIPT' || node.id === OVERLAY_ID) {\n          continue\n        }\n\n        // Prefer elements with explicit data attributes\n        if (node.dataset?.['sanity']) {\n          addElement(node, node.dataset['sanity'])\n        }\n        // Look for legacy sanity data attributes\n        else if (node.dataset?.['sanityEditInfo']) {\n          addElement(node, node.dataset['sanityEditInfo'])\n        } else if (isImgElement(node)) {\n          const data = testAndDecodeStega(node.alt, true)\n          if (!data) continue\n          addElement(node, data)\n          // No need to recurse for img elements\n          continue\n        } else if (isTimeElement(node)) {\n          const data = testAndDecodeStega(node.dateTime, true)\n          if (!data) continue\n          addElement(node, data)\n        } else if (isSvgRootElement(node)) {\n          if (!node.ariaLabel) continue\n          const data = testAndDecodeStega(node.ariaLabel, true)\n          if (!data) continue\n          addElement(node, data)\n        }\n\n        elements.push(...findSanityNodes(node))\n      }\n    }\n  }\n  return elements\n}\n\nexport function isSanityArrayPath(path: string): boolean {\n  const lastDotIndex = path.lastIndexOf('.')\n  const lastPathItem = path.substring(lastDotIndex, path.length)\n\n  return lastPathItem.includes('[')\n}\n\nexport function getSanityNodeArrayPath(path: string): string | null {\n  if (!isSanityArrayPath(path)) return null\n\n  const split = path.split('.')\n\n  split[split.length - 1] = split[split.length - 1].replace(/\\[.*?\\]/g, '[]')\n\n  return split.join('.')\n}\n\nexport function sanityNodesExistInSameArray(\n  sanityNode1: SanityNode,\n  sanityNode2: SanityNode,\n): boolean {\n  if (!isSanityArrayPath(sanityNode1.path) || !isSanityArrayPath(sanityNode2.path)) return false\n\n  return getSanityNodeArrayPath(sanityNode1.path) === getSanityNodeArrayPath(sanityNode2.path)\n}\n\nexport function resolveDragAndDropGroup(\n  element: ElementNode,\n  sanity: SanityNode | SanityStegaNode,\n  elementSet: Set<ElementNode>,\n  elementsMap: WeakMap<ElementNode, OverlayElement>,\n): null | OverlayElement[] {\n  if (!element.getAttribute('data-sanity')) return null\n\n  if (element.getAttribute('data-sanity-drag-disable')) return null\n\n  if (!sanity || !isSanityNode(sanity) || !isSanityArrayPath(sanity.path)) return null\n\n  const targetDragGroup = element.getAttribute('data-sanity-drag-group')\n\n  const group = [...elementSet].reduce<OverlayElement[]>((acc, el) => {\n    const elData = elementsMap.get(el)\n    const elDragDisabled = el.getAttribute('data-sanity-drag-disable')\n    const elDragGroup = el.getAttribute('data-sanity-drag-group')\n    const elHasSanityAttribution = el.getAttribute('data-sanity') !== null\n\n    const sharedDragGroup = targetDragGroup !== null ? targetDragGroup === elDragGroup : true\n\n    if (\n      elData &&\n      !elDragDisabled &&\n      isSanityNode(elData.sanity) &&\n      sanityNodesExistInSameArray(sanity, elData.sanity) &&\n      sharedDragGroup &&\n      elHasSanityAttribution\n    ) {\n      acc.push(elData)\n    }\n\n    return acc\n  }, [])\n\n  if (group.length <= 1) return null\n\n  return group\n}\n","import {v4 as uuid} from 'uuid'\nimport type {\n  ElementNode,\n  EventHandlers,\n  OverlayController,\n  OverlayElement,\n  OverlayOptions,\n  ResolvedElement,\n} from './types'\nimport {handleOverlayDrag} from './util/dragAndDrop'\nimport {findOverlayElement, isElementNode} from './util/elements'\nimport {\n  findSanityNodes,\n  isSanityArrayPath,\n  isSanityNode,\n  resolveDragAndDropGroup,\n} from './util/findSanityNodes'\nimport {getRect} from './util/geometry'\n\n/**\n * Creates a controller which dispatches overlay related events\n *\n * @param handler - Dispatched event handler\n * @param overlayElement - Parent element containing rendered overlay elements\n * @public\n */\nexport function createOverlayController({\n  handler,\n  overlayElement,\n  inFrame,\n  optimisticActorReady,\n}: OverlayOptions): OverlayController {\n  let activated = false\n  // Map for getting element by ID\n  const elementIdMap = new Map<string, ElementNode>()\n  // WeakMap for getting data by element\n  const elementsMap = new WeakMap<ElementNode, OverlayElement>()\n  // Set for iterating over elements\n  const elementSet = new Set<ElementNode>()\n  // Weakmap keyed by measureElement to find associated element\n  const measureElements = new WeakMap<ElementNode, ElementNode>()\n\n  const preventDefault = inFrame\n\n  let ro: ResizeObserver\n  let io: IntersectionObserver | undefined\n  let mo: MutationObserver\n\n  let activeDragSequence = false\n\n  // The `hoverStack` is used as a container for tracking which elements are hovered at any time.\n  // The browser supports hovering multiple nested elements simultanously, but we only want to\n  // highlight the \"outer most\" element.\n  //\n  // This is how it works:\n  // - Whenever the mouse enters an element, we add it to the stack.\n  // - Whenever the mouse leaves an element, we remove it from the stack.\n  //\n  // When we want to know which element is currently hovered, we take the element at the top of the\n  // stack. Since JavaScript does not have a Stack type, we use an array and take the last element.\n  let hoverStack: Array<ElementNode> = []\n  const getHoveredElement = () => hoverStack[hoverStack.length - 1] as ElementNode | undefined\n\n  function addEventHandlers(el: ElementNode, handlers: EventHandlers) {\n    el.addEventListener('click', handlers.click as EventListener, {\n      capture: true,\n    })\n    el.addEventListener('contextmenu', handlers.contextmenu as EventListener, {\n      capture: true,\n    })\n    // We listen for the initial mousemove event, in case the overlay is enabled whilst the cursor is already over an element\n    // mouseenter and mouseleave listeners are attached within this handler\n    el.addEventListener('mousemove', handlers.mousemove as EventListener, {\n      once: true,\n      capture: true,\n    })\n    // Listen for mousedown in case we need to prevent default behavior\n    el.addEventListener('mousedown', handlers.mousedown as EventListener, {\n      capture: true,\n    })\n  }\n\n  function removeEventHandlers(el: ElementNode, handlers: EventHandlers) {\n    el.removeEventListener('click', handlers.click as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('contextmenu', handlers.contextmenu as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('mousemove', handlers.mousemove as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('mousedown', handlers.mousedown as EventListener, {\n      capture: true,\n    })\n    el.removeEventListener('mouseenter', handlers.mouseenter as EventListener)\n    el.removeEventListener('mouseleave', handlers.mouseleave as EventListener)\n  }\n\n  /**\n   * Executed when element enters the viewport\n   * Enables an elements event handlers\n   */\n  function activateElement({id, elements, handlers}: OverlayElement) {\n    const {element, measureElement} = elements\n    addEventHandlers(element, handlers)\n    ro.observe(measureElement)\n    handler({\n      type: 'element/activate',\n      id,\n    })\n  }\n\n  /**\n   * Executed when element leaves the viewport\n   * Disables an elements event handlers\n   */\n  function deactivateElement({id, elements, handlers}: OverlayElement) {\n    const {element, measureElement} = elements\n    removeEventHandlers(element, handlers)\n    ro.unobserve(measureElement)\n    // Scrolling from a hovered element will not trigger mouseleave event, so filter the stack\n    hoverStack = hoverStack.filter((el) => el !== element)\n    handler({\n      type: 'element/deactivate',\n      id,\n    })\n  }\n\n  function setOverlayCursor() {\n    if (!inFrame || !optimisticActorReady) return\n\n    const hoveredElement = getHoveredElement()\n\n    if (!hoveredElement) return\n\n    const targetSanityData = elementsMap.get(hoveredElement)?.sanity\n\n    if (!targetSanityData || !isSanityNode(targetSanityData)) return\n\n    const dragGroup = resolveDragAndDropGroup(\n      hoveredElement,\n      targetSanityData,\n      elementSet,\n      elementsMap,\n    )\n\n    const cursor = dragGroup ? 'move' : 'auto'\n\n    handler({\n      type: 'overlay/setCursor',\n      element: hoveredElement,\n      cursor,\n    })\n  }\n\n  /**\n   * Stores an elements DOM node and decoded sanity data in state and sets up event handlers\n   */\n  function registerElement({elements, sanity}: ResolvedElement) {\n    const {element, measureElement} = elements\n\n    const eventHandlers: EventHandlers = {\n      click(event) {\n        const target = event.target as ElementNode | null\n\n        if (element === getHoveredElement() && element.contains(target)) {\n          if (preventDefault) {\n            event.preventDefault()\n            event.stopPropagation()\n          }\n\n          const sanity = elementsMap.get(element)?.sanity\n          if (sanity && !activeDragSequence) {\n            handler({\n              type: 'element/click',\n              id,\n              sanity,\n            })\n          }\n        }\n      },\n      contextmenu(event) {\n        if (!('path' in sanity) || !inFrame || !optimisticActorReady) return\n\n        // This is a temporary check as the context menu only supports array\n        // items (for now). We split the path into segments, if a `_key` exists\n        // in last path segment, we assume it's an array item, and so return\n        // early if it is some other type.\n        if (!sanity.path.split('.').pop()?.includes('[_key==')) return\n\n        const target = event.target as ElementNode | null\n        if (element === getHoveredElement() && element.contains(target)) {\n          if (preventDefault) {\n            event.preventDefault()\n            event.stopPropagation()\n          }\n          handler({\n            type: 'element/contextmenu',\n            id,\n            position: {\n              x: event.clientX,\n              y: event.clientY,\n            },\n            sanity,\n          })\n        }\n      },\n      mousedown(event) {\n        // prevent iframe from taking focus\n        event.preventDefault()\n\n        if (event.currentTarget !== hoverStack.at(-1)) return\n\n        if (element.getAttribute('data-sanity-drag-disable')) return\n\n        // disable dnd in non-studio contexts\n        if (!inFrame || !optimisticActorReady) return\n\n        const targetSanityData = elementsMap.get(element)?.sanity\n\n        if (\n          !targetSanityData ||\n          !isSanityNode(targetSanityData) ||\n          !isSanityArrayPath(targetSanityData.path)\n        )\n          return\n\n        const dragGroup = resolveDragAndDropGroup(element, sanity, elementSet, elementsMap)\n\n        if (!dragGroup) return\n\n        handleOverlayDrag({\n          element,\n          handler,\n          mouseEvent: event as MouseEvent,\n          overlayGroup: dragGroup,\n          target: targetSanityData,\n          onSequenceStart: () => {\n            activeDragSequence = true\n          },\n          onSequenceEnd: () => {\n            // delay drag sequence end to prevent click events from firing just after drag sequences\n            setTimeout(() => {\n              activeDragSequence = false\n            }, 250)\n          },\n        })\n      },\n      mousemove(event) {\n        eventHandlers.mouseenter(event)\n        const el = event.currentTarget as ElementNode | null\n        if (el) {\n          el.addEventListener('mouseenter', eventHandlers.mouseenter as EventListener)\n          el.addEventListener('mouseleave', eventHandlers.mouseleave as EventListener)\n        }\n      },\n      mouseenter() {\n        // If the Vercel Visual Editing provided by Vercel Toolbar is active, do not overlap overlays\n        if (\n          (document.querySelector('vercel-live-feedback') &&\n            element.closest('[data-vercel-edit-info]')) ||\n          element.closest('[data-vercel-edit-target]')\n        ) {\n          return\n        }\n        hoverStack.push(element)\n\n        handler({\n          type: 'element/mouseenter',\n          id,\n          rect: getRect(element),\n        })\n\n        setOverlayCursor()\n      },\n      mouseleave(e) {\n        function leave() {\n          hoverStack.pop()\n          const hoveredElement = getHoveredElement()\n\n          handler({\n            type: 'element/mouseleave',\n            id,\n          })\n\n          if (hoveredElement) {\n            const overlayElement = elementsMap.get(hoveredElement)\n            if (overlayElement) {\n              handler({\n                type: 'element/mouseenter',\n                id: overlayElement.id,\n                rect: getRect(hoveredElement),\n              })\n            }\n          }\n\n          setOverlayCursor()\n        }\n\n        /**\n         * If moving to an element within the overlay which handles pointer events, attach a new\n         * event handler to that element and defer the original leave event\n         */\n        function addDeferredLeave(el: ElementNode) {\n          const deferredLeave = (e: MouseEvent) => {\n            const {relatedTarget} = e\n            const deferredContainer = findOverlayElement(relatedTarget)\n            if (!deferredContainer) {\n              el.removeEventListener('mouseleave', deferredLeave as EventListener)\n              leave()\n            } else if (relatedTarget && isElementNode(relatedTarget)) {\n              el.removeEventListener('mouseleave', deferredLeave as EventListener)\n              addDeferredLeave(relatedTarget)\n            }\n          }\n          el.addEventListener('mouseleave', deferredLeave as EventListener)\n        }\n\n        const {relatedTarget} = e as MouseEvent\n        const container = findOverlayElement(relatedTarget)\n        const isInteractiveOverlayElement = overlayElement.contains(container)\n\n        if (isElementNode(container) && isInteractiveOverlayElement) {\n          return addDeferredLeave(container)\n        }\n\n        leave()\n      },\n    }\n\n    const id = uuid()\n    const sanityNode = {\n      id,\n      elements,\n      sanity,\n      handlers: eventHandlers,\n    }\n    elementSet.add(element)\n    measureElements.set(measureElement, element)\n    elementIdMap.set(id, element)\n    elementsMap.set(element, sanityNode)\n\n    io?.observe(element)\n\n    handler({\n      type: 'element/register',\n      id,\n      element,\n      rect: getRect(element),\n      sanity,\n      dragDisabled: !!element.getAttribute('data-sanity-drag-disable'),\n    })\n\n    if (activated) {\n      activateElement(sanityNode)\n    }\n  }\n\n  function updateElement({elements, sanity}: ResolvedElement) {\n    const {element} = elements\n    const overlayElement = elementsMap.get(element)\n    if (overlayElement) {\n      elementsMap.set(element, {...overlayElement, sanity})\n      handler({\n        type: 'element/update',\n        id: overlayElement.id,\n        rect: getRect(element),\n        sanity: sanity,\n      })\n    }\n  }\n\n  function parseElements(node: ElementNode | {childNodes: ElementNode[]}) {\n    const sanityNodes = findSanityNodes(node)\n    for (const sanityNode of sanityNodes) {\n      const {element} = sanityNode.elements\n      if (elementsMap.has(element)) {\n        updateElement(sanityNode)\n      } else {\n        registerElement(sanityNode)\n      }\n    }\n  }\n\n  function unregisterElement(element: ElementNode) {\n    const overlayElement = elementsMap.get(element)\n    if (overlayElement) {\n      const {id, handlers} = overlayElement\n      removeEventHandlers(element, handlers)\n      ro.unobserve(element)\n      elementsMap.delete(element)\n      elementSet.delete(element)\n      elementIdMap.delete(id)\n      handler({\n        type: 'element/unregister',\n        id,\n      })\n    }\n  }\n\n  function handleMutation(mutations: MutationRecord[]) {\n    let mutationWasInScope = false\n    // For each DOM mutation, we find the relevant element node and register or\n    // update it. This function doesn't handle checking if the node actually\n    // contains any relevant Sanity data, it just detects new or changed DOM\n    // elements and hands them off to `parseElements` to and determine if we\n    // have Sanity nodes\n    for (const mutation of mutations) {\n      const {target, type} = mutation\n      // We need to target an element, so if the mutated node was just a text\n      // change, we look at that node's parent instead\n      const node: Node | null = type === 'characterData' ? target.parentElement : target\n      // We ignore any nodes related to the overlay container element\n      if (node === overlayElement || overlayElement.contains(node)) {\n        continue\n      }\n\n      mutationWasInScope = true\n      if (isElementNode(node)) {\n        parseElements({childNodes: [node]})\n      }\n    }\n\n    // If the mutation is \"in scope\" (i.e. happened outside of the overlay\n    // container) we need to check if it removed any of the elements we are\n    // currently tracking\n    if (mutationWasInScope) {\n      for (const element of elementSet) {\n        if (!element.isConnected) {\n          unregisterElement(element)\n        }\n      }\n    }\n  }\n\n  function updateRect(el: ElementNode) {\n    const overlayElement = elementsMap.get(el)\n    if (overlayElement) {\n      handler({\n        type: 'element/updateRect',\n        id: overlayElement.id,\n        rect: getRect(el),\n      })\n    }\n  }\n\n  function handleResize(entries: ResizeObserverEntry[]) {\n    for (const entry of entries) {\n      const target = entry.target\n\n      if (isElementNode(target)) {\n        const element = measureElements.get(target)\n        if (!element) return\n        updateRect(element)\n      }\n    }\n  }\n\n  function handleIntersection(entries: IntersectionObserverEntry[]) {\n    if (!activated) return\n    for (const entry of entries) {\n      const {target} = entry\n      const match = isElementNode(target) && elementsMap.get(target)\n      if (!match) continue\n      if (entry.isIntersecting) {\n        activateElement(match)\n      } else {\n        deactivateElement(match)\n      }\n    }\n  }\n\n  function handleBlur(event: MouseEvent) {\n    const element = findOverlayElement(event.target)\n\n    if (element) {\n      if (element.dataset['sanityOverlayElement'] === 'capture') {\n        event.preventDefault()\n        event.stopPropagation()\n      }\n      return\n    }\n\n    hoverStack = []\n    handler({\n      type: 'overlay/blur',\n    })\n  }\n\n  function handleWindowResize() {\n    for (const element of elementSet) {\n      updateRect(element)\n    }\n  }\n\n  function handleKeydown(event: KeyboardEvent) {\n    if (event.key === 'Escape') {\n      hoverStack = []\n      handler({\n        type: 'overlay/blur',\n      })\n    }\n  }\n\n  function handleWindowScroll(event: Event) {\n    const {target} = event\n\n    if (target === window.document || !isElementNode(target)) {\n      return\n    }\n\n    for (const element of elementSet) {\n      if (target.contains(element)) {\n        updateRect(element)\n      }\n    }\n  }\n\n  function activate() {\n    if (activated) return\n    io = new IntersectionObserver(handleIntersection, {\n      threshold: 0.3,\n    })\n    elementSet.forEach((element) => io!.observe(element))\n    handler({\n      type: 'overlay/activate',\n    })\n    activated = true\n  }\n\n  function deactivate() {\n    if (!activated) return\n    io?.disconnect()\n    elementSet.forEach((element) => {\n      const overlayElement = elementsMap.get(element)\n      if (overlayElement) {\n        deactivateElement(overlayElement)\n      }\n    })\n    handler({\n      type: 'overlay/deactivate',\n    })\n    activated = false\n  }\n\n  function destroy() {\n    window.removeEventListener('click', handleBlur)\n    window.removeEventListener('contextmenu', handleBlur)\n    window.removeEventListener('keydown', handleKeydown)\n    window.removeEventListener('resize', handleWindowResize)\n    window.removeEventListener('scroll', handleWindowScroll)\n    mo.disconnect()\n    ro.disconnect()\n\n    elementSet.forEach((element) => {\n      unregisterElement(element)\n    })\n\n    elementIdMap.clear()\n    elementSet.clear()\n\n    hoverStack = []\n    deactivate()\n  }\n\n  function create() {\n    window.addEventListener('click', handleBlur)\n    window.addEventListener('contextmenu', handleBlur)\n    window.addEventListener('keydown', handleKeydown)\n    window.addEventListener('resize', handleWindowResize)\n    window.addEventListener('scroll', handleWindowScroll, {\n      capture: true,\n      passive: true,\n    })\n    ro = new ResizeObserver(handleResize)\n    mo = new MutationObserver(handleMutation)\n    mo.observe(document.body, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n\n    parseElements(document.body)\n    activate()\n  }\n\n  window.document.fonts.ready.then(() => {\n    for (const element of elementSet) {\n      updateRect(element)\n    }\n  })\n\n  create()\n\n  return {\n    activate,\n    deactivate,\n    destroy,\n  }\n}\n","import {createContext} from 'react'\nimport type {VisualEditingNode} from '../../types'\nimport type {SharedStateStore} from './sharedStateStore'\n\nexport interface SharedStateContextValue {\n  comlink?: VisualEditingNode\n  store: SharedStateStore\n}\n\nexport const SharedStateContext = createContext<SharedStateContextValue | null>(null)\n"],"names":["decodeSanityNodeData","VERCEL_STEGA_REGEX","vercelStegaDecode","createContext","byteToHex","i","push","toString","slice","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","Error","native","randomUUID","v4","options","buf","offset","rnds","random","arr","toLowerCase","unsafeStringify","getRect","element","domRect","getBoundingClientRect","x","scrollX","y","scrollY","w","width","h","height","offsetRect","rect","px","axis","rayIntersect","l1","l2","x1","y1","x2","y2","x3","y3","x4","y4","denominator","ua","ub","rectEqual","r1","r2","rayRectIntersections","line","rectLines","intersections","length","intersection","isDuplicate","j","sort","a","b","pointDist","p1","p2","Math","sqrt","findClosestIntersection","ray","targets","flow","rayOrigin","some","t","point","bounds","withinX","withinY","pointInBounds","min","closestIntersection","closestRect","target","firstIntersection","scaleRect","scale","origin","originX","originY","getRectGroupYExtent","rects","minGroupY","max","map","r","maxGroupY","document","body","scrollHeight","findRectSanityData","overlayGroup","find","e","elements","sanity","resolveInsertPosition","insertPosition","Object","values","every","v","left","right","top","bottom","calcMousePos","bodyBounds","clientX","clientY","window","buildPreviewSkeleton","mousePos","scaleFactor","children","querySelectorAll","childRects","child","tagName","offsetX","offsetY","maxWidth","calcGroupBoundsPreview","groupBoundsX","minGroupX","maxGroupX","offsetWidth","getRectGroupXExtent","groupBoundsY","canOffsetX","innerWidth","canOffsetY","canOffset","offsetDist","async","resetMinimapWrapperTransform","endYOrigin","prescaleHeight","handler","rectUpdateFrequency","previousRootStyleValues","Promise","resolve","transform","getComputedStyle","DOMMatrix","maxScroll","innerHeight","prevScrollY","addEventListener","style","transition","scrollTo","behavior","setTimeout","type","display","once","overflow","documentElement","minimapScaleApplied","mousePosInverseTransform","handleOverlayDrag","opts","mouseEvent","onSequenceStart","onSequenceEnd","button","focus","getAttribute","t1","filter","t2","dragGroup","disableMinimap","preventInsertDefault","documentHeightOverride","groupHeightOverride","initialMousePos","scaleTarget","minYScaled","groupHeight","padding","scaledRects","calcMinimapTransformValues","sequenceStarted","minimapPromptShown","mousedown","rectsInterval","setInterval","applyMinimap","skeleton","transformOrigin","applyMinimapWrapperTransform","then","groupRect","handleScroll","abs","deltaY","shiftKey","dispatchEvent","CustomEvent","handleMouseMove","preventDefault","inverseMatrix","inverse","transformedPoint","DOMPoint","matrixTransform","calcMousePosInverseTransform","newInsertPosition","rayLeft","rayRight","rayTop","rayBottom","calcInsertPosition","JSON","stringify","handleMouseUp","clearInterval","removeFrameListeners","removeKeyListeners","removeMouseListeners","handleKeyup","key","handleBlur","removeEventListener","isElementNode","HTMLElement","SVGElement","findNonInlineElement","parent","parentElement","findOverlayElement","el","dataset","sanityOverlayElement","OVERLAY_ID","testAndDecodeStega","str","isAltText","input","lastIndex","test","decoded","href","replace","err","console","error","decodeStega","node","nodeType","Node","ELEMENT_NODE","isImgElement","isTimeElement","isSvgRootElement","toUpperCase","isSanityNode","findCommonPath","first","second","firstParts","split","secondParts","maxLength","reverse","reduce","parts","part","join","findCommonSanityData","nodes","n","_i","sanityNodes","common","consistentValueKeys","path","findSanityNodes","addElement","data","measureElement","childNodes","textContent","sanityEditTarget","nodesInTarget","commonData","TEXT_NODE","id","sanityEditInfo","alt","dateTime","ariaLabel","isSanityArrayPath","lastDotIndex","lastIndexOf","substring","includes","getSanityNodeArrayPath","sanityNodesExistInSameArray","sanityNode1","sanityNode2","resolveDragAndDropGroup","elementSet","elementsMap","targetDragGroup","group","acc","elData","get","elDragDisabled","elDragGroup","elHasSanityAttribution","sharedDragGroup","createOverlayController","overlayElement","inFrame","optimisticActorReady","activated","elementIdMap","Map","WeakMap","Set","measureElements","ro","io","mo","activeDragSequence","hoverStack","getHoveredElement","removeEventHandlers","handlers","click","capture","contextmenu","mousemove","mouseenter","mouseleave","activateElement","addEventHandlers","observe","deactivateElement","unobserve","setOverlayCursor","hoveredElement","targetSanityData","cursor","registerElement","eventHandlers","event","contains","stopPropagation","sanity2","pop","position","currentTarget","at","querySelector","closest","leave","relatedTarget","container","isInteractiveOverlayElement","addDeferredLeave","deferredLeave","uuid","sanityNode","add","set","dragDisabled","updateElement","overlayElement2","parseElements","has","unregisterElement","delete","handleMutation","mutations","mutationWasInScope","mutation","isConnected","updateRect","handleResize","entries","entry","handleIntersection","match","isIntersecting","handleWindowResize","handleKeydown","handleWindowScroll","activate","IntersectionObserver","threshold","forEach","deactivate","disconnect","fonts","ready","passive","ResizeObserver","MutationObserver","attributes","characterData","childList","subtree","destroy","clear","SharedStateContext"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}},
    {"offset": {"line": 1403, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1409, "column": 0}, "map": {"version":3,"file":"create-data-attribute.js","sources":["file:///Users/ypeskov/Projects/CMS/Sanity3/nextjs-app/node_modules/next-sanity/node_modules/%40sanity/visual-editing-helpers/dist/index.js"],"sourcesContent":["import { createListenLogic, createRequestMachine, DOMAIN, MSG_HANDSHAKE_SYN, MSG_HANDSHAKE_SYN_ACK, MSG_HANDSHAKE_ACK, MSG_RESPONSE, MSG_HEARTBEAT, MSG_DISCONNECT } from \"@sanity/comlink\";\nimport { MSG_RESPONSE as MSG_RESPONSE2 } from \"@sanity/comlink\";\nimport { studioPath } from \"@sanity/client/csm\";\nimport { encodeSanityNodeData } from \"./_chunks-es/transformSanityNodeData.js\";\nimport { pathToUrlString, urlStringToPath } from \"./_chunks-es/transformSanityNodeData.js\";\nconst channelsToComlinkMap = {\n  \"handshake/syn\": MSG_HANDSHAKE_SYN,\n  \"handshake/syn-ack\": MSG_HANDSHAKE_SYN_ACK,\n  \"handshake/ack\": MSG_HANDSHAKE_ACK,\n  \"channel/response\": MSG_RESPONSE,\n  \"channel/heartbeat\": MSG_HEARTBEAT,\n  \"channel/disconnect\": MSG_DISCONNECT,\n  \"overlay/focus\": \"visual-editing/focus\",\n  \"overlay/navigate\": \"visual-editing/navigate\",\n  \"overlay/toggle\": \"visual-editing/toggle\",\n  \"presentation/toggleOverlay\": \"presentation/toggle-overlay\"\n}, comlinkToChannelsMap = {\n  [MSG_HANDSHAKE_SYN]: \"handshake/syn\",\n  [MSG_HANDSHAKE_SYN_ACK]: \"handshake/syn-ack\",\n  [MSG_HANDSHAKE_ACK]: \"handshake/ack\",\n  [MSG_RESPONSE]: \"channel/response\",\n  [MSG_HEARTBEAT]: \"channel/heartbeat\",\n  [MSG_DISCONNECT]: \"channel/disconnect\",\n  \"visual-editing/focus\": \"overlay/focus\",\n  \"visual-editing/navigate\": \"overlay/navigate\",\n  \"visual-editing/toggle\": \"overlay/toggle\",\n  \"presentation/toggle-overlay\": \"presentation/toggleOverlay\"\n}, convertToComlinkEvent = (event) => {\n  const { data } = event;\n  return data && typeof data == \"object\" && \"domain\" in data && \"type\" in data && \"from\" in data && \"to\" in data && (data.domain === \"sanity/channels\" && (data.domain = DOMAIN), data.to === \"overlays\" && (data.to = \"visual-editing\"), data.from === \"overlays\" && (data.from = \"visual-editing\"), data.type = channelsToComlinkMap[data.type] ?? data.type), event;\n}, convertToChannelsMessage = (message) => (message.domain === DOMAIN && (message.domain = \"sanity/channels\"), message.to === \"visual-editing\" && (message.to = \"overlays\"), message.from === \"visual-editing\" && (message.from = \"overlays\"), message.type = comlinkToChannelsMap[message.type] ?? message.type, message.type === \"channel/response\" && message.responseTo && !message.data && (message.data = { responseTo: message.responseTo }), (message.type === \"handshake/syn\" || message.type === \"handshake/syn-ack\" || message.type === \"handshake/ack\") && (message.data = { id: message.connectionId }), message), sendAsChannelsMessage = ({ context }, params) => {\n  const { sources, targetOrigin } = context, message = convertToChannelsMessage(params.message);\n  sources.forEach((source) => {\n    source.postMessage(message, { targetOrigin });\n  });\n}, createCompatibilityActors = () => ({\n  listen: createListenLogic(convertToComlinkEvent),\n  requestMachine: createRequestMachine().provide({\n    actions: {\n      \"send message\": sendAsChannelsMessage\n    }\n  })\n});\nfunction createDataAttribute(props) {\n  function normalizePath(path) {\n    return path ? typeof path == \"string\" ? studioPath.fromString(path) : path : [];\n  }\n  function toString(props2) {\n    if (!props2.id) throw new Error(\"`id` is required to create a data attribute\");\n    if (!props2.type) throw new Error(\"`type` is required to create a data attribute\");\n    if (!props2.path || !props2.path.length)\n      throw new Error(\"`path` is required to create a data attribute\");\n    const attrs = {\n      baseUrl: props2.baseUrl || \"/\",\n      workspace: props2.workspace,\n      tool: props2.tool,\n      type: props2.type,\n      id: props2.id,\n      path: typeof props2.path == \"string\" ? props2.path : studioPath.toString(props2.path)\n    };\n    return encodeSanityNodeData(attrs);\n  }\n  const DataAttribute = (path) => toString({\n    ...props,\n    path: [...normalizePath(props.path), ...normalizePath(path)]\n  });\n  return DataAttribute.toString = function() {\n    return toString(props);\n  }, DataAttribute.combine = function(attrs) {\n    return createDataAttribute({\n      ...props,\n      ...attrs\n    });\n  }, DataAttribute.scope = function(path) {\n    return createDataAttribute({\n      ...props,\n      path: [...normalizePath(props.path), ...normalizePath(path)]\n    });\n  }, DataAttribute;\n}\nfunction getQueryCacheKey(query, params) {\n  return `${query}-${typeof params == \"string\" ? params : JSON.stringify(params)}`;\n}\nconst IS_MAC = typeof window < \"u\" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), MODIFIERS = {\n  alt: \"altKey\",\n  ctrl: \"ctrlKey\",\n  mod: IS_MAC ? \"metaKey\" : \"ctrlKey\",\n  shift: \"shiftKey\"\n};\nfunction isHotkey(keys, event) {\n  return keys.every((key) => MODIFIERS[key] ? event[MODIFIERS[key]] : event.key === key.toUpperCase());\n}\nfunction isModKey(event) {\n  return event.key === (IS_MAC ? \"Meta\" : \"Ctrl\");\n}\nfunction isAltKey(event) {\n  return event.key === \"Alt\";\n}\nexport {\n  MSG_RESPONSE2 as MSG_RESPONSE,\n  createCompatibilityActors,\n  createDataAttribute,\n  getQueryCacheKey,\n  isAltKey,\n  isHotkey,\n  isModKey,\n  pathToUrlString,\n  urlStringToPath\n};\n//# sourceMappingURL=index.js.map\n"],"names":["createListenLogic","createRequestMachine","DOMAIN","MSG_HANDSHAKE_SYN","MSG_HANDSHAKE_SYN_ACK","MSG_HANDSHAKE_ACK","MSG_RESPONSE","MSG_HEARTBEAT","MSG_DISCONNECT","studioPath","encodeSanityNodeData","channelsToComlinkMap","comlinkToChannelsMap","convertToComlinkEvent","event","data","domain","to","from","type","sendAsChannelsMessage","context","params","sources","targetOrigin","message","responseTo","id","connectionId","convertToChannelsMessage","forEach","source","postMessage","createCompatibilityActors","listen","requestMachine","provide","actions","createDataAttribute","props","normalizePath","path","fromString","toString","props2","Error","length","attrs","baseUrl","workspace","tool","DataAttribute","combine","scope","MODIFIERS","alt","ctrl","mod","window","test","navigator","platform","shift","isHotkey","keys","every","key","toUpperCase","isAltKey"],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1521, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}